{"meta":{"title":"Yongbosmart","subtitle":" Follow excellence ,and success will chase you","description":"Follow excellence ,and success will chase U","author":"yongbosmart","url":"https://yongbosmart.github.io"},"pages":[{"title":"","date":"2018-05-06T01:42:31.884Z","updated":"2018-05-06T01:42:18.601Z","comments":true,"path":"baidu_verify_GyMbpHRSjz.html","permalink":"https://yongbosmart.github.io/baidu_verify_GyMbpHRSjz.html","excerpt":"","text":"GyMbpHRSjz"},{"title":"算法作业-有向图（2）","date":"2018-03-27T16:00:00.000Z","updated":"2018-05-05T08:22:27.438Z","comments":true,"path":"算法作业-有向图（2）.html","permalink":"https://yongbosmart.github.io/算法作业-有向图（2）.html","excerpt":"","text":"上次回顾：找图中的最短路径求得图中的强连通通路"},{"title":"About","date":"2018-04-27T03:23:29.000Z","updated":"2018-05-25T23:22:15.343Z","comments":true,"path":"about/index.html","permalink":"https://yongbosmart.github.io/about/index.html","excerpt":"","text":"关于我教育经历山东大学 2015年9月 - 2019年6月计算机科学与技术专业 本科 相关课程：数据结构，操作系统，算法设计与分析，机器学习，信息检索，计算机图形学，信息安全导论 技能 Java，C++，Bootstrap(熟悉) Java Web，Python, Tensorflow（努力精进中……） 水水的项目 团队项目 阅读理解系统 MyMajor交友App iBook读书交友软件 个人项目 宾馆客房管理系统 Web-个人博客 各种Java小游戏…… 现在的座右铭~Follow excellence, and success will follow you. Contact me邮箱：yongbosmart@gmail.com GitHub：https://github.com/yongbosmart"},{"title":"categories","date":"2018-04-30T12:40:46.000Z","updated":"2018-04-30T13:37:04.076Z","comments":false,"path":"categories/index.html","permalink":"https://yongbosmart.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-30T12:40:12.000Z","updated":"2018-04-30T13:35:27.751Z","comments":false,"path":"tags/index.html","permalink":"https://yongbosmart.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"networking&百练1287","slug":"networking","date":"2018-08-10T16:00:00.000Z","updated":"2018-08-11T08:19:09.977Z","comments":true,"path":"2018/08/11/networking/","link":"","permalink":"https://yongbosmart.github.io/2018/08/11/networking/","excerpt":"","text":"G:Networking软工夏令营上机题目G &amp; 百练1287 题目描述 总时间限制: 1000ms 内存限制: 65536kB 描述 You are assigned to design network connections between certain points in a wide area. You are given a set of points in the area, and a set of possible routes for the cables that may connect pairs of points. For each possible route between two points, you are given the length of the cable that is needed to connect the points over that route. Note that there may exist many possible routes between two given points. It is assumed that the given possible routes connect (directly or indirectly) each two points in the area. Your task is to design the network for the area, so that there is a connection (direct or indirect) between every two points (i.e., all the points are interconnected, but not necessarily by a direct cable), and that the total length of the used cable is minimal. 输入 The input file consists of a number of data sets. Each data set defines one required network. The first line of the set contains two integers: the first defines the number P of the given points, and the second the number R of given routes between the points. The following R lines define the given routes between the points, each giving three integer numbers: the first two numbers identify the points, and the third gives the length of the route. The numbers are separated with white spaces. A data set giving only one number P=0 denotes the end of the input. The data sets are separated with an empty line. The maximal number of points is 50. The maximal length of a given route is 100. The number of possible routes is unlimited. The nodes are identified with integers between 1 and P (inclusive). The routes between two points i and j may be given as i j or as j i. 输出 For each data set, print one number on a separate line that gives the total length of the cable used for the entire designed network. 样例输入 12345678910111213141516171819202122232425261 02 31 2 372 1 171 2 683 71 2 192 3 113 1 71 3 52 3 893 1 911 2 325 71 2 52 3 72 4 84 5 113 5 101 5 64 2 120 样例输出 12340171626 主要思路1.构造无向图。（这里利用矩阵的方法） 2.找出无向图中的最小生成树。 这里使用Kruskal算法，利用并查集写。 （就是做这道题时发现我对Kruskal的理解有一丢丢的失误= =，可见还是码出来最重要） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//============================================================================// Name : ex3.cpp// Author : yongbo// Version :// Copyright : Your copyright notice// Description : Hello World in C++, Ansi-style//============================================================================#include&lt;stdio.h&gt;#include&lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;int point[55];int findfather(int a)&#123; if(point[a]!=a)&#123; return findfather(point[a]); &#125;else&#123; return a; &#125;&#125;void unionab(int a,int b)&#123; if(findfather(a)!=findfather(b))&#123; point[a]=b; &#125;&#125;bool issame(int a,int b)&#123; if(findfather(a)==findfather(b)) return true; else return false;&#125;int main()&#123; int m; queue&lt;int&gt; answer; scanf(\"%d\",&amp;m); while(m!=0)&#123; int n; scanf(\"%d\",&amp;n); if(n==0)&#123; printf(\"%d\",0); printf(\"%s\",\"\\n\");// string s;// getline(cin,s); scanf(\"%d\",&amp;m); continue; &#125;else&#123; for(int i=0;i&lt;55;i++)&#123; point[i]=i; &#125; int line[n][3]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; scanf(\"%d\",&amp;line[i][j]); &#125; &#125; int graph[m+1][m+1]; int ans=0; int zuxian=-1; memset(graph,-1,sizeof(graph)); for(int i=0;i&lt;n;i++)&#123; int x=line[i][0],y=line[i][1],len=line[i][2]; if(graph[x][y]==-1||graph[x][y]&gt;len)&#123; graph[x][y]=len; graph[y][x]=len; &#125; &#125; int edge=0; for(int i=0;i&lt;n;i++)&#123; int minx=0,miny=0;// int min=105; for(int i=1;i&lt;=m;i++)&#123; for(int j=i+1;j&lt;=m;j++)&#123; //每次找最小的，找到后可以赋一个较大值 if(graph[i][j]&lt;min&amp;&amp;graph[i][j]!=-1)&#123; minx=i; miny=j; min=graph[i][j]; &#125; &#125; &#125; if(!(minx==0&amp;&amp;miny==0))&#123; if(!issame(minx,miny))&#123;//怎么保证单向呢 unionab(findfather(minx),findfather(miny)); ans+=min; edge++; &#125; graph[minx][miny]=105; graph[miny][minx]=105; &#125; answer.push(ans); &#125;// string s;// getline(cin,s); scanf(\"%d\",&amp;m); &#125; while(!answer.empty())&#123; printf(\"%d%s\",answer.front(),\"\\n\"); answer.pop(); &#125;// int m; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/categories/算法/"}],"tags":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"信息安全学习总结&复习纲要","slug":"信息安全","date":"2018-07-21T16:00:00.000Z","updated":"2018-07-22T02:51:47.002Z","comments":true,"path":"2018/07/22/信息安全/","link":"","permalink":"https://yongbosmart.github.io/2018/07/22/信息安全/","excerpt":"","text":"信息安全学习总结&amp;复习纲要by yongbo 基本概念 密码算法和协议又可以分为4个主要的领域： 对称加密：用于加密任意大小的数据块或数据流的内容，包括消息、文件、加密密钥、口令。 非对称加密：用户加密小的数据库，如原来加密密钥或者hash值。 数据完整性算法：用于保护数据块（如一条消息）的内容免于修改。 认证协议：有许多基于密码算法的认证方案，用于认证实体的真实性。 CIA三元组，数据、信息和计算服务的基本安全目标： 保密性：对信息的访问和公开进行授权限制，包括保护个人隐私和秘密信息。保密性缺失的定义是信息的非授权泄露。 完整性：防止对信息的不恰当修改或破坏，包括确保信息的不可否认性和真实性。完整性缺失的定义是对信息的非授权修改和毁坏。 可用性：确保对信息的及时和可靠的访问和使用。可用性的缺失是对信息和信息系统访问和使用的中断。 （真实性，可追溯性（追溯到负有安全责任的一方）） passive attacks（被动攻击） 对传输进行窃听和检测。攻击者的目标是获得传输的信息。（信息内容的泄露，流量分析）（难以检测可防止） active attacks（主动攻击） 对数据流进行修改或伪造数据流。（伪装，重播（再次发送），信息修改，拒绝服务）（难以预防可检测） 访问控制：限制和控制那些通过通信连接对主机和应用进行访问的能力。 数据保密性：防止传输的数据遭到被动攻击。 数据完整性：与主动攻击有关 不可否认性：接收方能证明消息是由发送方发出，发送方也能证明消息是被接收方收到。 传统加密技术 对称加密：至今仍是最为广泛的加密模型，代表：DES和AES。 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 5个基本模型 plaintext 明文：原始可理解的消息或数据，是算法的输入。 加密算法：加密算法对明文进行各种替代和变换。 密钥：加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。 密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。 解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。 •plaintext - the original message •ciphertext - the coded message •cipher - algorithm for transforming plaintext to ciphertext •key - info used in cipher known only to sender/receiver •encipher (encrypt)（加密） - converting plaintext to ciphertext •decipher (decrypt) （解密）- recovering ciphertext from plaintext •cryptography （密码学）- study of encryption principles/methods •cryptanalysis (code-breaking) - the study of principles/ methods of deciphering ciphertext without knowing key •cryptology - the field of both cryptography and cryptanalysis $Y=E(K,X), X=D(K,Y)$ 对加密信息的攻击类型 •ciphertext only （唯密文攻击，最容易防范） •only know algorithm / ciphertext, statistical, can identify plaintext •known plaintext （已知明文） •know/suspect plaintext &amp; ciphertext to attack cipher •chosen plaintext （选择明文） •select plaintext and obtain ciphertext to attack cipher •chosen ciphertext •select ciphertext and obtain plaintext to attack cipher •chosen text •select either plaintext or ciphertext to en/decrypt to attack cipher 加密算法满足以下两点，可以认为是计算上安全的： 破译密码的代价超出密文信息的价值 破译密码的时间超出密文信息的有效期 代替技术将明文字母替换成其他字母、数字和符合的方法。 Caesar密码对字母表中的每个字母，用它之后的第三个字母来代替。eg:a-&gt;d 可以扩展到移n位，有25种可能的密钥。公式(将字母对应成数字)$C=E(k,p)=(p+k)\\mod 26\\\\ p=D(k,C)=(C-k)\\mod26$ caesar密码的三个重要特征使得可以采用穷举攻击分析方法： 1.已知加密和解密算法 2.需测试的密钥只有25个 3.明文所用的语言是已知的，且其意义易于识别。 Monoalphabetic Cipher 单表替代密码替代密码是指先建立一个替换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文，替代密码的密钥就是其替换表 。 （单表有一个固定的替换表） 将得到的密文上26个字母的任意置换。（一个具有n个元素的集合有n!个置换。）密钥数目大大增加（eg,26!&gt;4×$10^{26}$) 但是仍不安全，问题是语言特征规律。 •human languages are redundant •letters are not equally commonly used 单表代替密码，带有原始字母使用频率的一些统计学特征， 有两种方法可以减少代替密码里明文结构在密文中的残留度： 1.对明文中的多个字母一起加密。 2.采用多表代替密码 playfair 密码（多字母代替密码）最著名的多字母代替密码，它把明文中的双字母音节作为一个单元并将其转换成密文的“双字母音节”。 基于一个由密钥词构成的5×5字母矩阵。 本例使用的密钥词是monarchy。填充矩阵的方法是：首先将密钥词（去掉重复字母）从左向右，从上到下填在矩阵格子里。再将剩余的字母（除去密钥词里的字母）一次填在矩阵的格子里。I/J认为是一个字母。 （如果一种语言字母超过25个，可以去掉使用频率最少的一个。如，法语一般去掉w或k，德语则是把i和j合起来当成一个字母看待。英语中z使用最少，可以去掉它。 ） （1）如果该字母对的两个字母是相同的，那么在它们之间加一个填充字母，比如x。balloon$\\to$ba lx lo on (2)落在矩阵同一行的明文字母对中的字母由其右边的字母来代替。每行最右边的一个字母就用该列最左边的字母来代替。ar-&gt;RM (3) 落在矩阵同一列的明文字母对中的字母由其下面的字母来代替，每行最下面的一个字母，就该用该列最上面的字母来代替。比如mu$\\to$CM (4) 其他的每组明文字母对中的字母，按如下方式代替，该字母所在行为(该字母的)密文所在行，另一个字母所在列为（该字母的）密文所在列。hs$\\to$BP，ea$\\to$IM/JM （5）•如果最后剩下一个单个的不成对的字母，不加密 b\u0002 有26×26=675个字母对 认为比较安全，但仍然相对容易攻破。因为它的密文仍然完好地保留了明文语言的大部分结构特征。 多表代替密码（Vigenere密码）对简单单表代替的改进方法是在明文消息中采用不同的单表代替。这种方法一般称之为多表代替密码。所有这些方法都有以下的共同特征： （1）采用相关的单表代替规则集。 （2）密钥决定给定变换的具体规则。 最简单最著名的多表加密算法：Vigenere密码。在单一恺撒密码的基础上扩展出多表密码 如何使用字母表加解密，如果知道密钥长度，能否进行解密 TO BE OR NOT TO BE THAT IS THE QUESTION 当选定RELATIONS作为密钥时，加密过程是：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K，依此类推，得出对应关系如下： 密钥:RELAT IONSR ELATI ONSRE LATIO NSREL 明文:TOBEO RNOTT OBETH ATIST HEQUE STION 密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 又如： 在维吉尼亚（Vigenère）的密码中，发件人和收件人必须使用同一个关键词或者同一文字章节，即密钥。这个关键词或文字章节中的字母告诉他们怎么样才能前后改变字母的位置来获得该段信息中的每个字母的正确对应位置。比如如果关键字“BIG”被使用了，发件人将把信息按三个字母的顺序排列。第一个三字母单词的第一个字母将应当向前移动一个位置（因为B是排在A后面的字母），第二个字母需要向前移动8位（I是A后面第8个字母），而第三个字母需要向前移动6位（G是A后面第6个字母）。然后，文字就可以按下面的顺序来进行加密了： 未加密文字：THE BUTCHER THE BAKER AND THE CANDLESTICK MAKER。（屠夫、面包师和蜡烛匠）。 关键密钥：BIG BIGBIGB IGB IGBIG BIG BIG BIGBIGBIGBI GBIGB 加密文字：UPK CCZDPKS BNF JGLMX BVJ UPK DITETKTBODS SBSKS 密钥 如果知道“BIG”就是密钥，收件人就可以很容易地通过相应的位置改变字母位置，从而译出经过加密的文字。 每个明文都有多个密文字母，因此，字母的频率不太明显 但不是完全失去了 1）可以通过字母频率来确定使用的方法:单表法还是Vigenere密码 2）有时可以推断出key大小（破译能否取得进展将取决于能否判定密钥词的长度）如果两个相同的明文序列之间的距离是密钥词长度的整数倍，那么产生的密文序列也是相同的。 一次一密不可被攻破的，使用与消息一样长且无重复的随机密钥来加密消息。加密一次后丢弃不用。它产生的随机输出与明文没有任何关系，因为密文不包含明文的任何信息，所以无法可破。 （无条件安全，不可破译） 两大难点：a.产生大规模的随机密钥有实现困难。b.更令人担忧的是密钥的分配和保护。 一次一密是唯一的具有完善保密的密码体制。 其它（置换密码，轮转机，隐写术）置换密码是一种通过一定规则改变字符串中字符的顺序从而实现加密的密码算法。常见的是将明文字符串按照n个一行形成矩阵，然后再按列读出 。（可以双重，多重置换） 块密码和数据加密标准（DES)流密码和块密码（分组密码） 流密码每次加密数据流的一位或一个字节。分组密码是将一个明文分组作为整体加密，通常得到与明文等长的密文分组，一般分组大小是64位或128位（高级加密标准）。 分组越长意味着安全性越高。 现代块密码 用途广泛，包括保密和身份验证，主要是DES(分组密码设计准则) 一种思想(加解密过程）：A$\\oplus B =C$ $C\\oplus B=A$(根据异或的性质) •LS-1: cycled left shift 1 bit •LS-2: cycled left shift 2 bit •IP = (n2, n6 , n3 , n1 , n4 , n8 , n5 , n7 )n1放在了第四个位置 ​ 1 2 3 4 5 6 7 8 •$IP^{-1}$=(n4, n1 , n3 , n5 , n7 , n2 , n8 , n6 )n4就放在第一个位置 ​ 1 2 3 4 5 6 7 8 (n6放在第8个位置，n1放在第二个位置，与上面对应) •$IP^{-1}$( IP( X ) )=X 代替：明文被密文代替 置换：明文元素序列置换。 扩散：明文 和 密文之间统计关系变得复杂 混淆： 密文和 加密密钥之间 统计关系变复杂。 DES算法把64位的明文输入块变为64位的密文输出块,它所使用的密钥也是64位（实际用到了56位，第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1） DES是以64bit明文为一个单位来进行加密的，这个64bit的单位称为分组。 上一轮如何加密得到下一轮64bit，函数怎么来的，加完密如何解密。不一定考怎么设计，但是最关键结构！！ Feistel 密码（DES基本结构）基本公式：$f_{k}=(L\\oplus F(R,SK),R)$ L:左四位输入；R:右四位输入；SK:8位子密钥；F:映射函数 本质上实现了输入和输出的非线性 在这里，加密的各个步骤称为轮，整个加密步骤就是进行若干次轮的循环。（多轮网络，难以破解）DES是一种16轮循环的Feistel网络。 Feistel 密码的流程，也是DES的一次循环过程。 输入分为左边和右边各32bit，子密钥是本轮加密使用的密钥，子密钥是一个局部密钥，仅在一轮中使用。 轮函数根据右侧和子密钥生成对左侧的加密序列，它是密码系统的核心，将轮函数的输出（用于加密的序列），与左侧进行xor，从而得到加密的效果。而输入的右侧原样输出。 这样右侧没有进行加密，因此需要用不同的子密钥对一轮进行处理，并在两轮处理之间，将左侧和右侧数据对调，最后一轮结束之后不需要对调。（课本得到LE16,Re16之后，进行对调后再输出了LE17,RE17，但是在解密时依旧用的是LE16，RE16) 解密：只要按照相反的顺序使用子密钥就可以了。（用相同的子密钥运行两次Feistel就能将数据还原（左右侧不对调的情况下），根据$\\oplus$的相关性质） 特点：feistel轮数可以任意叠加；轮函数使用任何函数都可以正确解密；加密和解密可以用完全相同的结构实现。 DES加密 事实上，明文处理经历了3个阶段： 64位明文经过初始置换Ip被重新排列。然后进入16轮相同函数的作用，每轮作用都有置换和代替。最后一轮输出有64位，左半部分和右半部分对调后输出。最后预输出再被与初始置换IP互逆的置换$IP^{-1}$作用产生64位密文。除了初始与末尾的置换，DES结构与Feistel结构相同。 图中右半部分给出了使用56位密钥的过程，密钥经过一个置换后，在经过循环左移和一个置换分别的都各轮的子密钥$K_{i}$用于各轮的迭代。每轮置换函数一样，但由于循环移位使子密钥不同。 雪崩效应：明文或密钥的微小改变将对密文产生很大的影响是任何加密算法需要的一个好性质。明文密钥某一位变化$\\to$密文很多位变化 DES的强度： 56位密钥一共有$2^{56}种情况,7.2\\times10^{16}$ DES过程初始置换IP及其逆置换$IP^{-1}$ IP置换就是将一个分组的64bits按照IP表按位重排。看第一个ip表，表示的意思是将64位明文P的第58位放在第1位，把原来的第50位调到第2位。$IP^{-1}$正好将IP调整的位置调回原位 函数F(·,·)的细节 E置换-》XOR-》S盒-》P置换 扩展置换E与P置换 扩展置换的功能是把$R_{i-1}$传来的32bits扩展为48bits，以便与48bits的子密钥$K_{i}$进行异或运算。 P盒置换是将S盒输出的32位结果又来一次置换。【置换规则和IP相同】 S盒变换 S盒变换又称压缩替换，通过S盒将48位输入变换成32位输出。是DES中唯一的非线性结构。DES算法中用了8个结构相似的S盒，每个S盒能够将6位的输入变成4位的输出。8个则将48位-》32位。 【6位数字，取第一位和最后一位作为行号，取中间四位作为列号，找到S盒中对应的&lt;16的数，转化为4位2进制】 轮密钥是怎样生成的初始密钥：56bit+8bit校验 置换PC-1:将初始密钥中不在8的整数倍位置上的数，置换到56位上，置换规则同IP等相似，有置换表。 置换PC-2：一个压缩置换，将56位的输入压缩变换成48位。有置换表。 附：3DES 加密$C=E_{k1}(D_{k2}(E_{k1}(P)))$ 解密$P=D_{k1}(E_{k2}(D_{k1}(C)))$ 分组密码的模式模式分组密码只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。 ECB,CBC,CFB,OFB,CTR 明文分组：作为加密对象的明文，=分组密码算法的分组长度 密文分组：分组密码算法将明文分组加密之后所产生的密文。 ECBECB：电子密码本。直接分块加密。在ECB模式中，将明文分组加密之后的结果将直接成为密文分组。 快速高效，可以同时处理。 信息的重复会显示出来 不安全：攻击者可以改变密文分组的顺序，当接受者对密文进行解密时，由于密文分组的顺序变了，解密出的明文顺序也会不对。这时，攻击者无需破译密码，既可以操纵明文。除此之外，攻击者还可以将密文分组进行删除、复制等操作。（if有消息认证码可以检测，but用其它模式不会出现这样的问题） CBC模式（密文分组链接模式）密文分组像链条一样相互连接在一起。 首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。 前面的块作为后面的块的输入——连在一起 • 需要一个初始的64位数据（向量）即IV 一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。 与ECB区别：ECB模式只进行了加密，而CBC模式则在加密前进行了一次XOR 特点： 安全性较好，加密过程是串行的，无法被并行化。解密可以并行化。 每个密文块都依赖于所有的消息块，因此，消息中的更改会影响更改后的所有密文块以及原始块。 但是，如果IV是明文发送的，攻击者可以更改第一个块的位，并更改IV以补偿，因此IV必须是一个固定值(如EFTPOS)，或者必须在消息其余部分之前以ECB模式加密发送 【？？？即可对初始化向量进行攻击】 在消息的末尾，通过填充已知的非数据值(如null)或使用填充大小为pad size的pad last块来处理可能的最后短块 如。[b1 b2 b3 0 0 0 0 0 0 5] &lt;- 3数据字节，然后5字节pad+计数 数论和有限域b|a: b整除a,b是a的因子。 a|b,b|c,则a|c。 欧几里得算法 Euclid &amp; GCD:arrow_forward: 两个整数称为互素的，如果它们唯一的正整数公因子为1. ▶️ gcd(a,b):a,b的最大公因子。gcd(0,0)=0. gcd(a,b)=max[k,其中k|a且k|b] 所求最大公因子为正数，一般来说gcd(a,b)=gcd(|a|,|b|),同样，因为0可被所有非零整数整除，所以gcd(a,0)=|a|。 如果gcd(a,b)=1,那么a和b互素 ▶️ 【基于java】： a mod b（仅正数）和a%b（结果有正有负）相差不多，均表示求余数。$a\\equiv b \\mod c$ (a,b模c同余) ▶️ 欧几里得算法 d= GCD(a,b) = GCD(b, a mod b) （b ，a和b的余数） 1234567891011121314151617A=a, B=bwhile B&gt;0 R = A mod B A = B, B = Rreturn A （B=0,返回A)Example GCD(1970,1066)1970 = 1 x 1066 + 904 gcd(1066, 904)1066 = 1 x 904 + 162 gcd(904, 162)904 = 5 x 162 + 94 gcd(162, 94)162 = 1 x 94 + 68 gcd(94, 68)94 = 1 x 68 + 26 gcd(68, 26)68 = 2 x 26 + 16 gcd(26, 16)26 = 1 x 16 + 10 gcd(16, 10)16 = 1 x 10 + 6 gcd(10, 6)10 = 1 x 6 + 4 gcd(6, 4)6 = 1 x 4 + 2 gcd(4, 2)4 = 2 x 2 + 0 gcd(2, 0)[一直到余数=0，这里结果为2] 模运算:arrow_forward:a模n：a除以n所得的余数。 $11\\mod 7=4, \\quad-11\\mod 7=3; \\\\ 73\\equiv 4(mod23) \\to 73-4=23\\times3 \\\\ 21\\equiv -9(\\mod 10) \\to 21-(-9)=10\\times 3 $ 如果$a\\equiv 0(\\mod n)$,则n|a。 :arrow_forward:(a+b) mod n = [a mod n + b mod n] mod n (a-b) mod n = [a mod n - b mod n] mod n (a×b) mod n = [a mod n × b mod n] mod n 乘法逆a的乘法逆元：与a相乘得到单位元的值。 群、环、域:arrow_forward:群，二元运算的集合。满足1封闭性，2结合律，3单位元，4逆元。如果群的元素个数有限，则成为有限群。群的阶就等于群中元素的个数。否则，称为该群为无限群。 如果群满足5交换律，称为交换群，即阿贝尔群。 求幂运算为重复运用群中的运算。 :arrow_forward:环{R,+,×}一个有两个二元运算的集合。a封闭率b结合律c分配率。 乘法交d换律和乘法e单位元。f无零因子：如果R中有元素a、b，且ab=0,则必有a=0或b=0。 :arrow_forward:域，整环，满足12345+abcdef， 存在乘法逆元，$aa^{-1}=e$ 有限域$GF(大素数)，GF(2^{n})$ 有限域的阶（元素的个数）必须是一个素数的幂$p^{n}$,n为正整数。阶为$p^{n}$的有限域一把记为$GF(p^{n})$,n=1,GF(p),与n&gt;1时有着不同的结构。 Galois fields(伽罗瓦域) –GF(p) ( for n=1) –$–GF(2^n) (for \\quad p=2 )$ (for p=2 ) GF(p)是整数集合{0,1, … , p-1} （整数集合$Z_p$) ,运算是模p的算术运算 如果a和b互素，则b有模a的乘法逆元。【注意：互素是前提】 即如果gcd(a,b)=1,那么b有模a的乘法逆元。对于b&lt;a,存在$b^{-1}&lt;a$，使$bb^{-1}=1\\mod a$ (ax+by) mod a = [ax mod a + by moda ] mod a =by mod 1 $y=b^{-1}$，因此用扩展欧几里得算法。 扩展的欧几里得算法及求乘法逆元不仅计算出最大公因子d，还应该计算出另外两个整数x,y,它们满足如下方程： $ax+by=d=gcd(a,b)$(其中，x和y具有相反的正负号。) 递推公式：$x_{i}=x_{i-2}-q_{i}x_{i-1}$和$y_{i}=y_{i-2}-q_{i}y_{i-1}$ 余数 公式 x,y 满足 $x_{-1}=1;y_{-1}=0$ $a=ax_{-1}+by_{-1}$ $x_{0}=0;y_{0}=1$ $b=ax_{0}+by_{0}$ $r_{1}=a\\mod b$ $a=q_{1}b+r_{1}$ $x_{1}=x_{-1}-q_{1}x_{0}\\\\y_{1}=y_{-1}-q_{1}y_{0}$ $r_{1}=ax_{1}+by_{1}$ $r_{n}=r_{n-2}\\mod r_{n-1}$ $r_{n-2}=q_{n}r_{n-1}+r_{n}$ $x_{n}=x_{n-2}-q_{n}x_{n-1}\\\\y_{n}=y_{n-2}-q_{n}y_{n-1}$ $r_{n}=ax_{n}+by_{n}$ $r_{n+1}=r_{n-1}\\mod r_{n}=0$ $r_{n-1}=q_{n+1}r_{n}+0$ $d=gcd(a,b)=r_{n}\\\\x=x_{n}\\quad y=y_{n}$ 对于求乘法逆的例子，由于要求a,b为素数，最后的结果一般如下： 待处理余数 公式 x y $r_{n}=1$ $r_{n-2}=q_{n}r_{n-2}+1$ $x_{n}=x_{n-2}-q_{n}x_{n-1}$ $y_{n}=y_{n-2}-q_{n}y_{n-1}$ d=1 $x=x_n$ ✔️ $y=y_n$✔️ 对于任意的n,如果运用扩展欧几里得算法可以用于求取$Z_{n}​$内的乘法逆元。如果运用扩展欧几里得算法于方程nx+by=d，并且得到d=1,则在$Z_{n}​$内有$y=b^{-1}​$ 公钥密码学与RSA解决密钥分发的几种方法： 1.通过事先共享密钥解决 2.通过密钥分配中心（KDC) 3.通过Diffie-Hellman 4.通过公钥密码来解决 轮转机/DES基于替换，置换方法上。 公钥密码非对称，使用两个独立的密钥。公钥密码的处理过程不比传统密码中的那些过程更简单，也并不比之更有效。 【公钥密码学-》密码学界唯一&amp;最伟大的一次革命】 基本概念： 非对称密钥：两个密钥：公钥和私钥，用来实现互补运算，即加密和解密，或者生成签名与验证签名。 公钥证书：认证机构将用户的姓名和公钥绑定在一起，用户用自己的私钥对数字文件签名后，可以通过证书识别签名者。签名者是唯一拥有与证书上对应的私钥的用户。 公钥密码（非对称密码）算法：公钥，私钥。从公钥中推出私钥在计算上不可行。 公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。 公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。通过这种算法得到的密钥对能保证在世界范围内是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，必须用另一个密钥解密。 特定：加解密算法相同，密钥不同；发送方和接收方拥有不同密钥，两密钥之一必须保密，知道算法和其中一个密钥不能推出另一个密钥 :arrow_forward:加密：公钥加密，私钥解密【消息】 :arrow_forward:签名：私钥加密，公钥认证【解密】 可以既保密又认证，eg:a -&gt; b, PUb{s,PRa}. 【加密，解密，密钥交换】 寻找合适的单向陷门函数是公钥密码体制应用的关键。 对公钥密码的要求公钥对的生成很容易。 加密在计算上很容易(知道明文M和KU)。 解密在计算上很容易(知道密文C和KR)。 从KU中找到KR是不可行的。 从KU和密文中找到明文是不可行的。 加密和解密函数顺序是可交换的 【为防止穷举攻击，用较长的密钥，但是加解密比较慢】 RSA算法明文和密文均是0至n-1之间的证书，n的大小通常为1024位的2进制，或309位的十进制。 生成RSA密钥每个用户生成一个私钥/公钥对，通过： 随机选择两个大素数p,q;【保密的，选定的】 计算系统的模量：N=pq 【公开的，计算得到的】 注意有$\\phi(N)$ =(p-1)(q-1)【比N小又与N互素的数的个数】 随机选择e,满足gcd($\\phi(N),e$)=1；1&lt;e&lt;$\\phi(N)$ 【公开的，选定的】 解出d,d满足$d\\equiv e^{-1}(\\mod \\phi(N))$【保密的，计算得出的(扩展欧几里得算法?)】 即 ed=1mod $\\phi(N)$且1&lt;d&lt;$\\phi(N)$ 【ed互为模$\\phi(N)$的乘法逆】 公布公钥{e,N}；保存私钥{d,N} 【乘法幂回顾】 如果a和b互素，则b有模a的乘法逆元。【注意：互素是前提】 即如果gcd(a,b)=1,那么b有模a的乘法逆元。对于b&lt;a,存在$b^{-1}&lt;a$，使$bb^{-1}=1\\mod a$ RSA的使用明文分组M和密文分组C: $C=M^e \\mod n；(0\\leq M&lt;N) \\\\ M=C^d \\mod n =(M^e \\mod n)^d \\mod n =M^{ed} \\mod n (0\\leq C&lt;N)$ 因此，有$M^{ed} \\mod n =M$ PPT:$C^d = (M^e)^d = M^{1+k.ø(N)} = M^1.(M^{ø(N)})^{k} = M^1.(1)^k = M1 = M mod N =M $ RSA浅析【欧拉定理】数论中的欧拉定理（费马-欧拉定理），表明，若n,a为正整数，且n,a互质，则$a^{\\phi(n)}\\equiv 1 \\mod n$ 在RSA中，N=pq,$\\phi(N)=(p-1)(q-1)$选择mod N互逆的ed,得到$ed=1+k\\phi(N)$ RSA证明$M^{ed} \\mod n =M$ 1.M和p不互素，p可以整除M。则M mod p=0，$M^{ed}\\mod p=0$ 2.M和p互素，根据欧拉公式，$M^{\\phi(p)} \\mod p=1$ $M^{ed}\\mod p=M^{1+k\\phi(p)}\\mod p\\\\=(M\\mod p)\\times ((M^{(p-1)})^{k(q-1)}\\mod p)\\\\=(M\\mod p)\\times ((M^{\\phi(p)})^{k(q-1)}\\mod p)\\\\=(M\\mod p)\\times 1^{k(q-1)}=M\\mod p$ 由于p和q对称，且p,q均为素数。 则同样有$M^{ed}\\mod q=M \\mod q$ 由于pq互质，pq=N，则根据中国余数定理：$M^{ed} \\mod N=M$ (0$\\leq$M&lt;N,大于n（1024bit）可能会有部分解不出来) 【中国余数定理】$如果n_1,n_2,\\cdots n_k两两互质，n=n_1n_2n_3\\cdots n_k,则对于所有的整数x和a,\\\\x\\equiv a(\\mod n_i)当且仅当 x\\equiv a(\\mod n)$ [错误证明，差点一错再错，而且是一个重点🔼 TAT 😭 ] 2.M和N互素，根据欧拉公式，$M^{\\phi(N)} \\mod N=1$ $M^{ed}\\mod n=M^{1+k\\phi(n)}\\mod n\\\\=(M\\mod n)\\times ((M^{(p-1)})^{k(q-1)}\\mod n)\\\\=(M\\mod n)\\times ((M^{\\phi(p)})^{k(q-1)}\\mod n)\\\\=(M\\mod n)\\times 1^{k(q-1)}=M\\mod n$ RSA计算及技巧 RSA安全性关键在于大数的分解，当N（1024bit）很大时，分解成两个素数很难 如何选择素数pq? pq最好不相差太大【PPT P30,米勒什么什么算法检验】 （求d和求pq是否等价暂无定论） 3种攻击：1.暴力密钥搜索：（找密钥d),但是e,dN位数较高，难以实现 2.数学攻击，分解N,暂无对大整数进行质因数分解的高效算法。【指在求pq】 3.时间攻击【通过隐藏时间信息防范】 （不知道P和Q,只知道ø(N)也是可以破解的 ？？） RSA明文具备的性质 证明RSA,可恢复 在 mod n范围内进行计算 密钥管理及其它公钥密码体制离散对数问题在整数中，离散对数是一种基于同余运算和原根的一种对数运算。而在实数中对数的定义 $log_b a$ 是指对于给定的 a 和 b，有一个数 x，使得$b^{x}$ = a。相同地在任何群 G中可为所有整数 k定义一个幂数为$b^{k}$，而离散对数是 $log_b a$指使得$b^{x}$ = a的 整数 k。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 Diffie-Hellman 密钥交换Diffie-Hellman是一种建立密钥的方法，而不是加密方法。然而，它所产生的密钥可用于加密、进一步的密钥管理或任何其它的加密方式。Diffie-Hellman密钥交换算法及其优化首次发表的公开密钥算法出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学。 【第一个公钥密码系统，可以进行密钥交换】 安全性这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密. Diffie-Hellman密钥交换算法的有效性依赖于计算离散对数的难度 。 :aries: 【单纯D-H依旧难以预防中间人攻击，仍需要对公钥拥有者的身份进行验证】 :star:PPT例题【P21】 主要过程 所有用户都知道的全局参数 大素数q g : 用来模q的原始根 每个用户生成自己的公钥(对于用户A) 选择一个密钥，(私钥)：数字 $x_{A}$&lt;q 计算公钥：$y_{A}=g^{x_{A}}\\mod q$ 每个用户公开公钥 则用户A&amp;B共享的会话密钥是$K_{AB}$ K_{AB}=g^{x_{A}· x_{B}} \\mod q​ =y_{A}^{x_{B}}\\mod q (B可以计算出来) ​ =y_{B}^{x_{A}}\\mod q (A可以计算出来) From WIKI： 最简单，最早提出的这个协议使用一个质数p的整数模n乘法群)以及其原根g。下面展示这个算法，绿色表示非秘密信息, 红色粗体表示秘密信息 爱丽丝和鲍伯写上一个有限循环群 G 和它的一个生成元 g。 （这通常在协议开始很久以前就已经规定好； g是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 a(很大) 并且将 $g^{a}\\mod p$（大素数）发送给鲍伯。 鲍伯选择一个随机自然数 b （很大）并且将 $g^{b}\\mod p$发送给爱丽丝。 爱丽丝 计算 $(g^{b})^{a} \\mod p$ 。 鲍伯 计算 $(g^{a})^{b} \\mod p$ 。 爱丽丝和鲍伯就同时协商出群元素$g^{ab}$，它可以被用作共享秘密。$(g^{b})^{a}$和$(g^{a})^{b}$因为群乘法交换的。 算法解释爱丽丝和鲍伯最终都得到了同样的值，因为在模p下$g^{ab}$和 $g^{ba}$ 相等。 注意a, b 和 $g^{ab}= g^{ba} \\mod p$ 是秘密的。 其他所有的值 – p, g, $g^{a} \\mod p$, 以及 $g^{b}\\mod p $– 都可以在公共信道上传递。 一旦爱丽丝和鲍伯得出了公共秘密，他们就可以把它用作对称密钥，以进行双方的加密通讯，因为这个密钥只有他们才能得到。 Elgamal密码体制1984年，T.Elgamal提出了一种基于离散对数的公开密钥体制，是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。ElGamal密码体系应用于一些技术标准中，如数字签名标准（DSS）和S/MIME电子邮件标准。与Diffie-Hellman一样，ElGamal的系统用户也是共同选择一个素数q，$g$是q的素跟。 算法描述ElGamal加密算法由三部分组成：密钥生成、加密和解密。 密钥生成密钥生成步骤如下： Alice利用生成元 $g$ 产生一个 q,阶循环群 $G$,的有效描述。该循环群需要满足一定的安全性质。 Alice从 $\\{1,\\cdots,q-1\\}$中随机选择一个 $x$。 Alice计算 $h:=g^{x} \\mod q $。 Alice公开$h$,以及 $G,q,g$ 的描述作为其公钥，并保留 $x$ 作为其私钥。私钥必须保密。 加密其他用户可以通过Alice的公钥进行加密。 用Alice的公钥 $(G,q,g,h)$向她加密一条消息 m的加密算法工作方式如下： 将信息表示成一个整数M，其中$1\\leq M \\leq q-1$，以分组密码序列的方式来发送信息，其中每个分块的长度不小于整数q。 Bob从 $\\{1,\\cdots,q-1\\}$ 随机选择一个 $y$。（私钥） 然后计算 密钥$K=h^{y} \\mod q$。（会话密钥） 将M加密成明文对$(C_{1}，C_{2})$，其中 $C_{1}=g^{y} \\mod q ; C_{2}=K\\cdot M \\mod q $（公钥，加密的信息） 解密Alice利用自己的私钥进行解密。 得到密钥：$K=(C_{1})^{x} \\mod q$ 得到消息$M = (C_{2}K^{-1}) \\mod q$ 如果信息必须分组，然后以加密的密钥块序列发送，那么每个分块要有唯一的x（私钥）。如果x用于多个分块，则利用信息的分块$M_{1}$，攻击者会计算出其他块。 ElGamal的安全性是基于计算离散对数的困难性之上。 椭圆曲线密码【本章节很多内容已经在课本上圈圈画画了，包括比较重要的计算】 Elliptic Curve Cryptography 什么样的公式可以被称为椭圆曲线，ECC加解密过程，ECC与RSA的对比，ECC的相关计算 我们将椭圆曲线的方程限制为以下形式： $y^{2}=x^{3}+ax+b$ 加密解密[课本230]考虑如下等式： K=kG [其中 K,G为Ep(a,b)上的点，k为小于n（n是点G的阶）的整数] 给定k和G，根据加法法则，计算K很容易；但 给定K和G，求k就相对困难了。 这就是椭圆曲线加密算法采用的难题。我们把点G称为基点（base point），k（k&lt;n，n为基点G的阶）称为私有密钥（privte key），K称为公开密钥（public key)。 现在我们描述一个利用椭圆曲线进行加密通信的过程：1、用户A选定一条椭圆曲线Ep(a,b)，并取椭圆曲线上一点，作为基点G。2、用户A选择一个私有密钥k，并生成公开密钥K=kG。3、用户A将Ep(a,b)和点K，G传给用户B。4、用户B接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r（r&lt;n）。5、用户B计算点$C_1 =M+rK；C_2 =rG$。6、用户B将$C_1 、C_2 $传给用户A。7、用户A接到信息后，计算$C_1 -kC_2$ ，结果就是点M。因为 $ C_1 -kC_2 =M+rK-k(rG)=M+rK-r(kG)=M$ 再对点M进行解码就可以得到明文。 通过K、G 求k 或通过C_2 、G求r 都是相对困难的 实现密钥交换D_HA-&gt;a-(私钥)&gt;aG（公钥） B-&gt;b(私钥)-&gt;bG 会话密钥：abG 消息认证和Hash函数Hash 函数简介首要目标-》保证数据完整性。 【消息认证】确保收到的信息和发送时一样（即没有修改、插入、删除重放等）通常还需保证发送方身份真实有效。当Hash函数提供消息认证功能时，Hash函数值通常称为消息摘要。 为防止中间人攻击，要对生成的hash值进行加密。更一般的，消息认证通过MAC实现，即带密钥的hash函数。 两种简单的hash函数，1.分组后直接异或。2.分组后，每一组循环左移，再与上一次hash值异或。 但都是容易被破解的：就是如果每一个比特取反，异或后结果还是一样的。因此移位也是很容易找到两个不同的消息有一样的hash值。 但两个都不安全。另一种采用CBC的方式，由于异或可以任意顺序计算，因此改变密文分组的顺序不会造成影响。 Hash 函数的要求1 可以应用于任何大小的消息M2 产生固定长度的输出h【任意长度-》（输出）固定长度】3 对于任何消息M，都很容易计算h= H(M) 4 给定h，不可求x 即 h (x)=h求x是不可行的 【单向性质】5 给定分块x求出y不可行的，其中H(y)=H(x) 【抗弱碰撞性】6 找到任何满足H(y)=H(x)的偶对在计算上是不可行的 【抗强碰撞性】（对hash函数要求高） 抗弱碰撞性包括抗强碰撞性。 MD5：哈希算法的一种，常用于文件的唯一标识。用于确保信息传输完整一致。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串） SHA1:是使用最广泛的hash算法的一种，建立在MD4只上，输出为160位hash值。 安全哈希算法主要适用于数字签名标准里面定义的数字签名算法。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 对hash函数的两种攻击方式 暴力破解 生日攻击 A发送消息x, 第三方产生$2^{\\frac{m}{2}}$种变式x’,且每一种变式表达相同意义，存hash值。同时伪造消息y,造y的变式y’，且也表达同样的意义。然后计算H(y’),并与任意的H(x’)进行比对，直到找到某个H(y’)=H(x’) 则攻击者将变式x‘给A获取签名，然后将签名附在y’后发给接收方。 代价数量级，2^{m/2} 找到两个不同的消息，具有相同的hash值。利用“两个集合相交”问题的原理生成散列函数碰撞，达到目的的攻击称为生日攻击，也称为平方根攻击 。 这种攻击对Hash函数提出了一个必要的安全条件，即消息摘要必须足够长。 【试图破解强碰撞性】 单向散列函数无法解决的问题能够辨别出“篡改”，但无法辨别“伪装”。用于认证的技术-&gt;数字签名，消息认证码。认证需要使用密钥【只有Alice才知道的秘密信息】 其它密钥分发 基于对称加密的对称密钥分发 用户和KDC(密钥分发中心)共享密钥，分为密钥分发步骤和认证步骤。 密钥分发步骤，a提出请求，KDC把密钥给A并把B的消息也给它，然后a发给b并进行密钥认证。【认证得到的是同一个会话密钥】，可以记得用f(Na) 基于非对称加密的对称密钥分发 即用公钥私钥交换会话密钥，注意中间人攻击。【公钥少用于大数据块的加密，多用于小数据快】 确认保密性和身份认证的密钥分发 【随机数可以确认身份哦】 公钥分发 公开可访问的目录 里面有{姓名，公钥},但是攻击者盗用管理员私钥后gg 公钥证书 通信双方通过证书来交换密钥，证书保护公钥和公钥拥有者的标志。由可信的第三方进行签名。【1.关于分发2.协商会话密钥】 消息认证【伪装-内容修改-消息顺序修改-重放攻击重播】 可以用hash，Mac，消息加密【加密后的消息作为认证】 消息加密作为认证，因为密钥仅两方共有，不过不可识别随机码，但是可以增加错误控制。校验码，让明文是易于识别的结构。 消息认证码：MAC:确认消息完整性并对消息进行认证的技术。 消息认证码的输入包括任意长度的消息 和 一个发送者接收者之间共享的密钥。 同时发送消息和mac值，接收方用同样的密钥得到Mac进行比对。 MAC=C(K,M)，C:MAC函数 1）判断消息未修改2）由于有密钥，所以可以确定消息来自真正的发送方。3）序列号保证消息顺序正确。 MAC函数应当有以下要求1.若攻击者已知M和MAC(K,M)，构造MAC(K,M’)=MAC(K,M)计算上不可行 2.MAC(K,M)均匀分布，MAC(K,M’)=MAC(K,M)概率是$2^{-n}$[阻止基于明文的选择攻击] 3.已知M’=f(M),M’是M已知的变换，比如讲M一位多位取反等。要求 Pr[MAC(K,M’)=MAC(K,M)]=$2^{-n}$[认证算法对消息某部分或位不应当比其他部分或位更弱] 【能不能用会话密钥进行认证呢？假如发送的是随机的内容，随机码，会话密钥不太好进行认证；负荷比较大，要求完全解密】 应用实例 IPSEC SSL/TLS 实现方式 单向散列函数 HMAC 使用分组密码实现消息认证码。 会遭受的攻击 重放攻击 解决方法【加一个递增序号】【加时间戳】【加随机数】 暴力攻击&amp;生日攻击 消息认证码无法解决的问题：对第三方证明消息的发送者、eg，b向c证明消息确实是由a发送的；防止否认：a可能会否认自己向b发送过这个消息。 用数字签名解决。 数字签名【防止发送方否认】生成签名 验证签名。数字签名对签名密钥【私钥】和验证密钥【公钥】进行了区分，使用验证密钥是无法生成签名的。签名密钥只能由签名的人持有，而验证密钥任何需要验证签名的人都可以持有。 1.直接对消息签名 2.对消息的散列值签名 【签名把签名和特定的消息绑定在一起】 消息认证可以保护信息交换双方不受第三方的攻击，但是它不能处理通信自身双方发生的攻击，如发送方否认。在收发双方不能完全信任的情况下，用数字签名，数字签名需要有以下几点特征： 1.它必须能验证签名者，签名日期和时间；2.它必须能认证被签的消息内容。3.签名应该由第三方仲裁，以解决政治。 因此数字签名具有认证功能。 数字签名的性质• must depend on the message signed【取决于消息】• must use information unique to sender【用了与发送方唯一相关的信息】– to prevent both forgery and denial【防止伪造和否认】• must be relatively easy to produce【易于生成】• must be relatively easy to recognize &amp; verify【相对容易认证/确认】• be computationally infeasible to forge【伪造数字签名计算不可行，无论是从给定的数字签名伪造消息，还是从给定的消息伪造数字签名】 – with new message for existing digital signature – with fraudulent digital signature for given message• be practical save digital signature in storage【实际保存数字签名存储】 直接数字签名，只涉及通信双方，签名在内层，发生争执时，第三方查看签名。 缺点：发送方可以谎称私钥丢失或者被盗。因此需要一个时间戳，并在密钥被泄密后及时汇报。【不过不可以防止时间戳造假】 用户认证Arbitrated Digital Signatures 仲裁数字签名，有第三方。 涉及到仲裁者A的使用：-验证任何已签名的消息-然后注明日期并发送给收件人 •要求对仲裁者有适当程度的信任 •可以使用私有或公钥算法实现 •仲裁者可能看到信息，也可能看不到 【认证用户身份一般需要的工具 1.你本身性质body you are（DNA) 2.你有什么（令牌，like id，门禁卡什么的） 3.你知道什么 remember什么 密码什么的】【有的时候这几种可以同时使用】 认证协议：用于说服对方以交换会话密钥。可以是单向or双向。机密性-》会话密钥。及时性-》需要防止重放攻击。 重放攻击：复制并重新发送有效的签名的消息。防止措施：使用序号（不常用）；时间戳（需要统一时钟）；【挑战/应答】随机码 [挑战/应答，随机码]不适用于无连接类型的传输。 {因为在无连接传输之前的握手开销。实质上是否定了无连接传输的主要优点。} 基于对称加密的远程用户认证 双向认证 双向认证协议能使通信双方互相认证彼此身份并交换会话密钥 在分布式环境中，可以用一个两层的对称加密密钥。该方案需要可信的密钥分发中心（KDC)参与，每一方和KDC之间都共享一个密钥（称为主密钥）。KDC负责产生两者的会话密钥，并用主密钥来保证会话密钥的安全分发。 步骤4反映b收到密钥，步骤5使b明确自己和a的密钥一样【第三步可能会被重放】或者会话密钥泄露，第三方截获步骤四，伪装a发送步骤五。 注意这里时间戳也加密了。第二步的随机数换成了时间戳。 【时间戳，用时间确定】 需要保证时钟同步。 可以只根据b的时间订，可以看一下课本P346. 总的来说，主要注意：随机数-》除了防止重放，另一个作用是消息确实来源于自己，或消息和自己有关 随机数，防止重放+消息和发送方有关。时间戳，防止重放，时间双方均可验证；或者随机数加密验证ks更具有代表性吧 看以下：因为时间戳需要重复利用，因此用随机数。 Kerberos【单向认证】单向认证：电子邮件式，接收者确认信息来自发送者。 一种方法【对称密钥】： A→KDC: ID A || IDB || N 1 KDC→A: E Ka [Ks || ID B || N 1 || E Kb [Ks||ID A ] ] A→B: E Kb [Ks||ID A ] || E Ks [M] 不能抵抗重放攻击，也可以添加时间戳，但是电子邮件可能延误。 一种方法 非对称密钥 A→B: E KUb [Ks] || E Ks [M] (保密性)A→B: M || E KRa [H(M)] || E KRas [T||ID A ||KU a ] （认证性，后半部分是证书）可以看做a的证书，对a的公钥的签名认证a的 Kerberos通过提供一个集中的授权服务器来负责用户对服务器的认证和服务器对用户的认证。Kerberos仅仅依赖于对称加密体制而没有使用公钥加密体制。 在一个开放的网络环境中，所有用户都可以向任一服务器请求服务。每个服务器为了认证用户的合法性就必须知道每一个用户口令。显然网络规模越大维护越复杂，所以引入：认证服务器（AS）：它将所有用户的口令集中存放在本地数据库中；而且它与每一个应用服务器共享一个唯一的密钥。（密钥通过物理的或其他安全的方式分发）客户端（C）：代替用户与服务器进行信息交换。票据（Ticket） ：身份或权利的证明。Ticket 由 AS 以数据报形式发放给 C。 票据许可服务器 （TGS）向已经通过TGS认证的用户发放服务Ticket。用户首先向AS请求一张票据许可票 Ticket tgs ，并将它保存在 C 中。每当用户要求一种新的服务时，客户便用这张能认证自己的 Ticket tgs 向TGS发出申请。TGS给用户发回一张针对某种特定服务的服务许可票据 Ticket V，客户将保留每一个Ticket V ，在每次请求相同服务时提供给服务器 V 来认证。 功能特性分析 可信的第三方Kerberos服务器 所需的密钥分配和管理变简单 AS负担认证工作，减轻应用服务器负担 安全相关数据集中管理和保护，使攻击者入侵难以成功 Ticket 使AS（TGS）的认证结果和会话密钥安全传给C和TGS（应用服务器） 生存期内可重用，减少认证开销，提高方便性 共享密钥 为认证提供安全依据 TGS 降低用户口令的使用频度，提供更好的口令保护 减轻AS负担，提高系统效率 Session Key 防止非法用户窃得Ticket进行重放攻击 提供了对服务器的认证 时间戳 防止对Ticket和认证符的重放攻击 局限性分析Kerberos服务器易受攻击– 它的安全性决定了整个系统得安全性，若此关键环节发生问题，危害是灾难性的。 口令攻击– 对手截获基于口令的密钥加密的内容，采用暴力破解成功后，得到口令也就到该用户的全部资源域间认证复杂完全没有任何非对称加密的技术，有一些局限性，可以用非对称加密算法避免 用于非对称加密的远程用户认证双向认证 需要保证是正确的公钥，使用central Authentication Server (AS)，时间戳。【看课本吧360页】 改进，在56步中的证书里，加入IDa，保证请求唯一来自于A 对数字签名的攻击 中间人攻击 对单向散列函数的攻击 利用数字签名攻击公钥密码 数字签名无法解决的问题：用于验证签名的公钥必须属于真正的发送者。确认公钥是否合法——证书！。 证书：就是把公钥当成一个消息，由一个可信的第三方对其签名后得到的公钥。PKI【公钥基础设施】 证书公钥证书PKC 由认证机构（CA）施加数字签名 对证书的攻击 1.在公钥注册之前攻击。即a发送公钥去认证是，e将a的公钥替换成自己的。【so a在认证时应该将自己的公钥用认证机构公钥加密】 2.攻击者伪装成认证机构进行攻击。自己成立一个认证机构，给自己的公钥颁发证书，并声称是“Bob”的公钥【要注意的证书的颁发机构】 SSL\\TLS SSL记录协议–建立在可靠的传输协议(如TCP)之上–它提供连接安全性，有两个特点• 保密性，使用了对称加密算法• 完整性，使用HMAC算法–用来封装高层的协议• SSL握手协议–客户和服务器之间相互鉴别–协商加密算法和密钥–它提供连接安全性，有三个特点• 身份鉴别，至少对一方实现鉴别，也可以是双向鉴别• 协商得到的共享密钥是安全的，中间人不能够知道• 协商过程是可靠的 零知识证明它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。大量事实证明，零知识证明在密码学中非常有用。如果能够将零知识证明用于验证，将可以有效解决许多问题。 （1）完备性。如果证明方和验证方都是诚实的，并遵循证明过程的每一步，进行正确的计算，那么这个证明一定是成功的，验证方一定能够接受证明方。（2）合理性。没有人能够假冒证明方，使这个证明成功。（3）零知识性。证明过程执行完之后，验证方只获得了“证明方拥有这个知识”这条信息，而没有获得关于这个知识本身的任何一点信息。 “零知识证明”是密码学中存在于“证明者（prover，以下用P代替）”和“验证者（verifier，以下用V代替）”双方的一种协议，这种协议的要求是： P使得V相信其拥有某知识 V不能从证明过程中得到知识的任何信息 为了使得V相信P拥有知识，证明须满足， 完备性：如果P确实拥有知识，那么证明成功的概率大于2/3 可靠性：如果P并不拥有知识，那么证明成功的概率小于1/3 若证明满足上面的条件，则通过反复多次的证明，就能使得V相信P拥有知识的概率趋近1，P不拥有知识的概率趋近0。 （零知识(ness性):验证者除了知道陈述是真实的之外，没有学到任何信息 ） 图的三色问题，是指找到这样一种染色方法，将图的顶点用三种颜色中的一种染色，并使得相邻顶点不同色。假如P找到了图G满足三色问题的一种染色方法，想要证明给V，他应该怎么做呢(O.O)? P随机选择一种颜色的置换方式（如红-蓝，蓝-黄，黄-红），将原来的染色方案按照颜色置换重新染色。将染色过后的G放在密封的信封里发给V。 随机选择图中的一条边，并要求P打开这条边的两个顶点。 P打开相应的信封，展示顶点的颜色。 如果展示的顶点颜色不同，则V接受证明。 完备性：如果P确实有三染色方案，那么证明必然成功。 可靠性：如果P没有三染色方案，那么他的染色方案中至少有一条边是顶点同色的。假设图G有n条边，那么证明失败的概率至少是1/n。如果证明进行m次，那么P人品爆表蒙混过关的概率就会小于(1-1/n)^m，当m足够大，这个概率就趋近于0。 而由于每次的随机颜色置换，V无法从揭示的边中获得任何染色方案的信息。因此这个证明是零知识证明。至于如何构造这样的“信封”，使得V在P开启信封前不能看到信封中的内容，而P也无法通过不同的”拆封”方式而操纵信封中的内容，这就是另外一种密码协议“承诺协议”的范围了。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://yongbosmart.github.io/categories/信息安全/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"https://yongbosmart.github.io/tags/课堂笔记/"},{"name":"信息安全","slug":"信息安全","permalink":"https://yongbosmart.github.io/tags/信息安全/"}]},{"title":"Diffie-Hellman 密钥交换&ElGamal协议的安全密钥交换","slug":"Diffie-Hellman 密钥交换","date":"2018-05-17T16:00:00.000Z","updated":"2018-05-19T07:42:08.697Z","comments":true,"path":"2018/05/18/Diffie-Hellman 密钥交换/","link":"","permalink":"https://yongbosmart.github.io/2018/05/18/Diffie-Hellman 密钥交换/","excerpt":"","text":"Diffie-Hellman 密钥交换&amp;ElGamal协议的安全密钥交换离散对数问题在整数中，离散对数是一种基于同余运算和原根的一种对数运算。而在实数中对数的定义 $log_b a$ 是指对于给定的 a 和 b，有一个数 x，使得$b^{x}$ = a。相同地在任何群 G中可为所有整数 k定义一个幂数为$b^{k}$，而离散对数是 $log_b a$指使得$b^{x}$ = a的 整数 k。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 Diffie-Hellman 密钥交换Diffie-Hellman是一种建立密钥的方法，而不是加密方法。然而，它所产生的密钥可用于加密、进一步的密钥管理或任何其它的加密方式。Diffie-Hellman密钥交换算法及其优化首次发表的公开密钥算法出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学。 这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密. Diffie-Hellman密钥交换算法的有效性依赖于计算离散对数的难度 。 主要过程 所有用户都知道的全局参数 大素数q g : 用来模q的原始根 每个用户生成自己的公钥(对于用户A) 选择一个密钥，(私钥)：数字 $x_{A}$&lt;q 计算公钥：$y_{A}=g^{x_{A}}\\mod q$ 每个用户公开公钥 则用户A&amp;B共享的会话密钥是$K_{AB}$ K_{AB}=g^{x_{A}· x_{B}} \\mod q​ =y_{A}^{x_{B}}\\mod q (B可以计算出来) ​ =y_{B}^{x_{A}}\\mod q (A可以计算出来) From WIKI： 最简单，最早提出的这个协议使用一个质数p的整数模n乘法群)以及其原根g。下面展示这个算法，绿色表示非秘密信息, 红色粗体表示秘密信息 爱丽丝和鲍伯写上一个有限循环群 G 和它的一个生成元 g。 （这通常在协议开始很久以前就已经规定好； g是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 a(很大) 并且将 $g^{a}\\mod p$（大素数）发送给鲍伯。 鲍伯选择一个随机自然数 b （很大）并且将 $g^{b}\\mod p$发送给爱丽丝。 爱丽丝 计算 $(g^{b})^{a} \\mod p$ 。 鲍伯 计算 $(g^{a})^{b} \\mod p$ 。 爱丽丝和鲍伯就同时协商出群元素$g^{ab}$，它可以被用作共享秘密。$(g^{b})^{a}$和$(g^{a})^{b}$因为群乘法交换的。 算法解释爱丽丝和鲍伯最终都得到了同样的值，因为在模p下$g^{ab}$和 $g^{ba}$ 相等。 注意a, b 和 $g^{ab}= g^{ba} \\mod p$ 是秘密的。 其他所有的值 – p, g, $g^{a} \\mod p$, 以及 $g^{b}\\mod p $– 都可以在公共信道上传递。 一旦爱丽丝和鲍伯得出了公共秘密，他们就可以把它用作对称密钥，以进行双方的加密通讯，因为这个密钥只有他们才能得到。 Elgamal密码体制1984年，T.Elgamal提出了一种基于离散对数的公开密钥体制，是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。ElGamal密码体系应用于一些技术标准中，如数字签名标准（DSS）和S/MIME电子邮件标准。与Diffie-Hellman一样，ElGamal的系统用户也是共同选择一个素数q，$g$是q的素跟。 算法描述ElGamal加密算法由三部分组成：密钥生成、加密和解密。 密钥生成密钥生成步骤如下： Alice利用生成元 $g$ 产生一个 q,阶循环群 $G$,的有效描述。该循环群需要满足一定的安全性质。 Alice从 $\\{1,\\cdots,q-1\\}$中随机选择一个 $x$。 Alice计算 $h:=g^{x} \\mod q $。 Alice公开$h$,以及 $G,q,g$ 的描述作为其公钥，并保留 $x$ 作为其私钥。私钥必须保密。 加密其他用户可以通过Alice的公钥进行加密。 用Alice的公钥 $(G,q,g,h)$向她加密一条消息 m的加密算法工作方式如下： 将信息表示成一个整数M，其中$1\\leq M \\leq q-1$，以分组密码序列的方式来发送信息，其中每个分块的长度不小于整数q。 Bob从 $\\{1,\\cdots,q-1\\}$ 随机选择一个 $y$。（私钥） 然后计算 密钥$K=h^{y} \\mod q$。（会话密钥） 将M加密成明文对$(C_{1}，C_{2})$，其中 $C_{1}=g^{y} \\mod q ; C_{2}=K\\cdot M \\mod q $（公钥，加密的信息） 解密Alice利用自己的私钥进行解密。 得到密钥：$K=(C_{1})^{x} \\mod q$ 得到消息$M = (C_{2}K^{-1}) \\mod q$ 如果信息必须分组，然后以加密的密钥块序列发送，那么每个分块要有唯一的x（私钥）。如果x用于多个分块，则利用信息的分块$M_{1}$，攻击者会计算出其他块。 ElGamal的安全性是基于计算离散对数的困难性之上。 参考资料[1]维基百科编者. 迪菲-赫尔曼密钥交换[G/OL]. 维基百科, 2018(20180503)[2018-05-03]. https://zh.wikipedia.org/w/index.php?title=%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B&amp;oldid=49408565. [2]《密码编码学与网络安全 原理与实践》（第6版）斯托林斯著 [3]维基百科编者. ElGamal加密算法[G/OL]. 维基百科, 2016(20161214)[2016-12-14]. https://zh.wikipedia.org/w/index.php?title=ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;oldid=42453545.","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://yongbosmart.github.io/categories/信息安全/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"https://yongbosmart.github.io/tags/课堂笔记/"}]},{"title":"半边数据结构&网格细分与简化","slug":"计算机图形学-半边数据结构","date":"2018-05-05T16:00:00.000Z","updated":"2018-05-09T13:40:51.653Z","comments":true,"path":"2018/05/06/计算机图形学-半边数据结构/","link":"","permalink":"https://yongbosmart.github.io/2018/05/06/计算机图形学-半边数据结构/","excerpt":"","text":"半边数据结构&amp;网格细分参考博客： https://blog.csdn.net/lafengxiaoyu/article/details/51524361 https://blog.csdn.net/outtt/article/details/78544053 http://www.cnblogs.com/shushen/p/5251070.html 对于表面网络来说，其重要的特点在于拓扑，也就是曲面是如何表达的，而不是其顶点的位置。拓扑的不同造就了不同的数据结构和标准，不同的拓扑，其进行网格查询和编辑的性能也不同。计算机图形学上，通常说的流形是一种几何模型表面（但不是所有的），即二维流形，对应拓扑流形。如果网格的每个边最多被两个面片共用，那么这个网格就是流形网络，否则称为非流形网络。 半边数据结构：最大特点是半边，每个边分为两个半边，每个半边都是一个有向边，方向相反。如果一个边被两个面片公用，则每个面片都能各自拥有一个半边。如果一个边仅被一个面片占用（边界边），则这个面片仅拥有该边的其中一个半边，另一个半边为闲置状态。每一条半边仅存储它的起点指针 半边数据结构仅支持流形网络。 半边数据结构的三个重要的数据结构——顶点、半边、面片 顶点(Vertex)：包含出半边（OutgoingHalfedge）的指针或索引 在半边数据结构中的点储存着x，y，z的位置和以其为起始点的半边的指针。在任意给定的点上存在超过一条我们可以选择的半边，但是我们只需要选择其中一条并且是哪一条没关系，在下面的查询方法中我们会看到解释。 12345678910struct HE_vert &#123; float x; float y; float z; HE_edge* edge; // one of the half-edges emantating from the vertex &#125;; 半边(HalfEdge)：包含终点（StartVertex）、邻接面(AdjacentFace)、下一条半边(NextHalfedge)、相反边（opposite）的指针或索引 12345678struct HE_edge &#123; HE_vert* vert; // vertex at the end of the half-edge HE_edge* pair; // oppositely oriented adjacent half-edge HE_face* face; // face the half-edge borders HE_edge* next; // next half-edge around the face &#125;; 面片(Face)：包含一条起始边（FirstHalfedge）的指针或索引对于一个半边数据结构的简单形式，一个面仅仅需要储存一个围绕它的边的指针，在一些特定场合可能要求我们储存比如材质和法向一类的信息。和上面一样，虽然有很多边围绕着面，我们只需要储存其中一条，而无所谓是哪一条 123456struct HE_face &#123; HE_edge* edge; // one of the half-edges bordering the face &#125;; 现在问题来了。顶点可能有两条或以上的出半边，而顶点的数据表达只有一条出半边，那这条出半边是哪一条？半边的下一条半边又是哪一条？面片的起始半边又是哪一条？通过某个网格的数据结构图（如图1）能看得出这些信息吗？ 答：事实上，半边数据结构的网格的构建通常是通过面列表来创建的，也就是说，正常的构建半边数据结构网格是通过一个一个面片的添加来构建的。 所以面的添加顺序就决定了点边面结构的信息，添加面的方法通常是addFace(a,b,c,…)，a,b,c…参数是该面片按其某条环路顺序排列的顶点的指针或索引。注意，环路可以是顺时针或者逆时针，决定了该面片的方向（法向量的方向）。 三维网格细分算法：Catmull-Clark subdivisionCatmull-Clark细分是一种四边形网格的细分法则，每个面计算生成一个新的顶点，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。 1.网格内部F-顶点位置： 设四边形的四个顶点为v0、v1、v2、v3，则新增加的顶点位置为v = $\\frac{1}{4}$ ×(v0 + v1 + v2 + v3)。 2.网格内部V-顶点位置： 设内部顶点v0的相邻点为v1、v2，…，v2n，则该顶点更新后位置为，其中α、β、γ分别为α = 1 - β - γ。 3.网格边界V-顶点位置： 设边界顶点v0的两个相邻点为v1、v2，则该顶点更新后位置为v = $\\frac{3}{4}×v0 +\\frac{1}{8}$×(v1 + v2)。 4.网格内部E-顶点位置： 设内部边的两个端点为v0、v1，与该边相邻的两个四边形顶点分别为v0、v1、v2、v3和v0、v1、v4、v5，则新增加的顶点位置为v = $\\frac{1}{4}$ (v0 + v1 + vf1 + vf2) = $\\frac{3}{8}$ (v0 + v1) + $\\frac{1}{16}$ (v2 + v3 + v4 + v5)。 5.网格边界E-顶点位置： 设边界边的两个端点为v0、v1，则新增加的顶点位置为v = $\\frac{1}{2}​$ (v0 + v1)。 Loop subdivisionLoop细分是一种三角形网格的细分法则，它按照1-4三角形分裂，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。下图为Loop细分格式的细分掩膜，对于新增加的顶点位置以及原始顶点位置更新规则如下： 1.网格内部V-顶点位置： 设内部顶点v0的相邻点为v1、v2，…，vn，则该顶点更新后位置为，其中。 2.网格边界V-顶点位置： 设边界顶点v0的两个相邻点为v1、v2，则该顶点更新后位置为 v = $\\frac{3}{4}$ ×v0 + $\\frac{1}{8}$ ×(v1 + v2)。。 3.网格内部E-顶点位置（新增点）： 设内部边的两个端点为v0、v1，相对的两个顶点为v2、v3，则新增加的顶点位置为v = $\\frac{3}{8}$ (v0 + v1) + $\\frac{1}{8}$(v2 + v3)。 网格内部某条边的两个端点为v0、v1，共享这条边的两个三角形的面是（v0，v1，v2）和（v0，v1，v3） 4.网格边界E-顶点位置（新增点）： 设边界边的两个端点为v0、v1，则新增加的顶点位置为v = $\\frac{1}{2}$×(v0 + v1)。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://yongbosmart.github.io/categories/计算机图形学/"}],"tags":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://yongbosmart.github.io/tags/计算机图形学/"}]},{"title":"算法作业-有向图","slug":"算法作业-有向图","date":"2018-03-25T16:00:00.000Z","updated":"2018-05-05T07:27:23.971Z","comments":true,"path":"2018/03/26/算法作业-有向图/","link":"","permalink":"https://yongbosmart.github.io/2018/03/26/算法作业-有向图/","excerpt":"","text":"算法作业​ 近期算法布置了一篇课设，在这里描述一下，并晒一下代码。整体来说算法实验很简单，实现方法也很简单粗暴，不过练习一下图的写法吧。 (PS.博主使用的是eclipse for C++，可以利用debug纠错) 问题描述 生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 将上述有向图变成dag图，从中去掉一些边，不允许使用递归 计算上述dag图中最长路径，并记录下路径 问题一生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 问题分析因为需要用邻接链表存储，因此需要用一个链表结构，基本结构如下： 123456789101112131415161718192021222324252627282930313233struct node&#123;public: node* next=NULL;//下一个 int weight=-1; int ini=0;//入度 int id=-1;//本node的编号public: void init(node* next,int length,int id)&#123;//初始化方法 this-&gt;next=next; this-&gt;weight=length; &#125; void init(int length,int id)&#123;//初始化方法 weight=length; this-&gt;id=id; &#125; void init(int id)&#123;//初始化方法 this-&gt;id=id; &#125; bool existedge(int i)&#123;//查看是否此边已存在。 node* current=this; if(i==id)&#123; return true; &#125;//自环 while(current-&gt;next!=NULL)&#123; if(current-&gt;next-&gt;id==i)&#123; return true; &#125; current=current-&gt;next; &#125; return false; &#125;&#125;; 这里，我写的node的性质比较多，但是事实上是完全没有必要的，如我的小伙伴就只存了一个id，后来证明她这种做法更为合理。 下面需要考虑建一个图需要什么样的方法，由于博主之前写过后缀树一类的，因此这个还是很easy的， 12345678910111213141516171819202122class Arithmex1 &#123;public: Arithmex1(int , int ); virtual ~Arithmex1(); int n=0;//顶点数 int e=0;//边数 int time=0; bool create() ;//创建图，是否存在边 bool insertEdge(int,int); //插入边 bool eraseEdge(int,int);//删除边 int weight(int,int);//某一边的权重 int distance(int);//任选一点为源点，计算s到其它点的距离 void dfs(int); int maxdis();//计算dag图中最长路径，并记录下路径 void dag();//将图变成dag图// 其他方法 bool directed(); void print();//图的打印&#125;; 下面开始图的主要代码： create方法： 123456789101112131415161718bool Arithmex1::create()&#123; srand(10);//设置随机数种子 graph=new node[n];//是一个装了node（首）的数组 for(int i=0;i&lt;n;i++)&#123; graph[i].init(1,i+1);//于是附上初值，权重为1，编号为i+1; &#125; int j=0; while(j&lt;e)&#123; int tmp1=rand()%n+1;//对应ID int tmp2=rand()%n+1;//dui if(!graph[tmp1-1].existedge(tmp2))&#123; insertEdge(tmp1,tmp2); &#125;else&#123; continue; &#125; j++; &#125;&#125; insertEdge方法(简单的，链表插入的方法)： 123456789101112131415bool Arithmex1::insertEdge(int a,int b)&#123;//插入边 if(!graph[a-1].existedge(b))&#123; node* current=&amp;graph[a-1]; while(current-&gt;next!=NULL)&#123; current=current-&gt;next; &#125; node *newnode=new node(); newnode-&gt;init(1,b); current-&gt;next=newnode; graph[b-1].ini++; return true; &#125; return false;&#125; 博主为了方便，写的方法比较粗暴，因此只是作为参考。值得注意的是，当我们以node来表示节点时，节点在存储空间内不止有一个。如下图：数组中有一个1，链表中2/4后也均有1，因此就像上面说的，在node struct中增加属性没有必要，且可能浪费空间，这时候一个好的做法是维护一个同等规模的数组来保存节点的属性 下面是需要计算源点s到图中各点的距离，显然可以用BFS,主要思路是维持一个数组存储长度，子节点的长度是父节点长度+1； 123456789101112131415161718192021222324252627282930313233343536373839int Arithmex1::distance(int i)&#123; int source=i; node* current=&amp;graph[source-1];//得到源点位置 int tip[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//标记，有没有被找到过 tip[j]=0; &#125; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离，有多远 tis[j]=-1;//开始认为不可达 &#125; tip[source-1]=-1;//设为首节点认为已标记 tis[source-1]=0;//距源点为0 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 if(tip[cnode-&gt;next-&gt;id-1]!=-1)&#123;//如果没有做过标记 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tip[cnode-&gt;next-&gt;id-1]=-1;//同时做上标记，已扫描// cout&lt;&lt;cnode-&gt;next-&gt;id&lt;&lt;\" \"&lt;&lt;tis[cnode-&gt;next-&gt;id-1]&lt;&lt;\" ]]\"; &#125; cnode=cnode-&gt;next;//去下一个 &#125; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;graph[i].id&lt;&lt;\"的距离是==&gt; \"&lt;&lt;tis[i]; cout&lt;&lt;endl; &#125;&#125; 问题二将上述有向图变成dag图，从中去掉一些边，不允许使用递归 问题分析这里的一个简单思路就是删除返回边。根据《算法导论》上的算法描述，即dfs时遇到灰色节点，边可被删除。难点主要在于白色、黑色、灰色（也可以是开始时间、结束时间）的判定。另一个难点在于不允许使用递归。这里面有很多种情况，需要仔细判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void Arithmex1::dfs(int start)&#123; //链表属性 node* current=&amp;graph[start-1];//得到源点位置 stack&lt;int&gt; ppid;//记录压入栈时的先驱点 stack&lt;node*&gt; dfss;//记录压入栈的node，有一个固定的id，只需要用id与遍历 ppid.push(-1);//起始点先驱点为-1 dfss.push(current);//放入当前点 while(!dfss.empty())&#123; node* newnode=dfss.top();//得到node// cout&lt;&lt;\"新一轮循环\"&lt;&lt;newnode-&gt;id&lt;&lt;endl; dfss.pop(); int tpid=ppid.top();//当前点newnode押出栈时的先驱点 ppid.pop();//当前节点先驱点 if(pro[newnode-&gt;id-1].color==0)&#123;//如果其颜色=0 pro[newnode-&gt;id-1].color =1;//pop出，正式找其它点，变灰色 pro[newnode-&gt;id-1].distime=++time;//发现时间 node* current=&amp;graph[newnode-&gt;id-1];//找到图中它的位置就可以遍历链表 int num=0;//是否变黑，只要push进去节点，说明都没有完成，完成的才变黑 while(current!=NULL&amp;&amp;current-&gt;next!=NULL)&#123;//遍历其邻接链表 if(pro[current-&gt;next-&gt;id-1].color ==0)&#123;//如果没有做过标记 pro[current-&gt;next-&gt;id-1].pid=newnode-&gt;id;//随时会变会更新的pid dfss.push(current-&gt;next);//压入栈 ppid.push(newnode-&gt;id);//这个对应的pid// cout&lt;&lt;\"放入\"&lt;&lt;current-&gt;next-&gt;id&lt;&lt;endl; num++;//操作未完成 &#125;else if(pro[current-&gt;next-&gt;id-1].color==1)&#123;//如果找到了灰色的，返回边。// cout&lt;&lt;current-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl;// cout&lt;&lt;current-&gt;next-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl; change=eraseEdge(newnode-&gt;id,current-&gt;next-&gt;id);//删除// print(); &#125; if(!change)&#123; current=current-&gt;next; &#125;else&#123; change=false; &#125; &#125; if(num==0)&#123;//叶子节点或者无用节点，本节点可以为0 pro[newnode-&gt;id-1].color=2;//黑色 pro[newnode-&gt;id-1].fintime=++time; //开始追根溯源 int tmpid=pro[newnode-&gt;id-1].pid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; // tmpid=pro[tmpid-1].pid; &#125; &#125; &#125;else if(pro[newnode-&gt;id-1].color==2)&#123;//早之前已经发现 int tmpid=tpid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123;// cout&lt;&lt;tmpid&lt;&lt;\"pout\"&lt;&lt;endl; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; &#125; &#125; &#125;&#125; 因为有的节点入度=0，即一次dfs会忽视它们，因此可以采用直接遍历的方法 1234567void Arithmex1::dag()&#123; for(int i=0;i&lt;n;i++)&#123; if(pro[i].color==0) dfs(i+1); &#125; print();&#125; 问题三计算上述dag图中最长路径，并记录下路径。 问题分析看到这个题，第一感觉是用拓扑序列，因为拓扑头一定是头结点。 但是博主又想偷懒了，拓扑头怎么求？在上文中，我们已经求出了结束时间最晚的那个节点，无疑一定是拓扑头。但是这里，博主直接采用的入度为0的为拓扑头，（再维持一个数组添加入度属性啦，插入边入度+1，删除边入度-1），这里，只要从拓扑头开始bfs（注意，这里让求的是最长路径，因此无需判断bfs时此点有没有访问过，而且是有向无环图，所以不会死循环） 这是一种比较简单的思路，却需要大量空间时间，另一种比较好的方法是完全用拓扑序列来实现。至于一些细节就不再赘述，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889int Arithmex1::maxdis()&#123; int* maxpid; maxpid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=-1; &#125; int* tmppid; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; int lastid=0; int realastid=-1; int maxdis=0; int cc=0; for(int i=0;i&lt;n;i++)&#123;//遍历顶点// cout&lt;&lt;graph[i].ini&lt;&lt;endl; if((graph[i].ini==0))&#123;//入度==0 cc++; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离长短 tis[j]=-1; &#125; tis[i]=0;//到自己的距离为0 int tmpdis=0;// tis[i]=1; node* current=&amp;graph[i];//得到源点位置 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tmpdis=tis[cnode-&gt;next-&gt;id-1]; lastid=cnode-&gt;next-&gt;id; tmppid[cnode-&gt;next-&gt;id-1]=tt-&gt;id; cnode=cnode-&gt;next;//去下一个 &#125; if(cnode-&gt;next==NULL)&#123; lastid=cnode-&gt;id; &#125; &#125; if(maxdis&lt;tmpdis)&#123; realastid=lastid; maxdis=tmpdis; maxpid=tmppid; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=tmppid[j];// cout&lt;&lt;tmppid[j]&lt;&lt;\"||\"&lt;&lt;maxpid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; &#125; &#125; &#125; tmppid=new int[maxdis+1]; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 tmppid[j]=-1; &#125; if(realastid!=-1)lastid=realastid; int jianyan=lastid; tmppid[maxdis]=lastid; int count=maxdis-1; while(jianyan!=-1)&#123; jianyan=maxpid[jianyan-1]; tmppid[count]=jianyan; count--; &#125; cout&lt;&lt;endl; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 cout&lt;&lt;tmppid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return maxdis;&#125; 更多完整代码参见https://github.com/yongbosmart","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"ccf1202-游戏","slug":"ccf1202-游戏","date":"2018-03-23T16:00:00.000Z","updated":"2018-04-30T13:36:44.665Z","comments":true,"path":"2018/03/24/ccf1202-游戏/","link":"","permalink":"https://yongbosmart.github.io/2018/03/24/ccf1202-游戏/","excerpt":"","text":"问题描述有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 问题分析用队列比较简单 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package oj;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class ccf1 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 int n, k; int tmp=1;//记录下一个要数的数 int result=-1; Scanner sc = new Scanner(System.in); n = sc.nextInt();// k =sc.nextInt(); Queue&lt;Integer&gt; cf=new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; cf.offer(i+1);// tmp++; &#125; if(n==1)&#123; result=cf.peek(); System.out.println(result); &#125;else&#123; while(cf.size()&gt;1)&#123;//循环往复的问题,,这里第一轮忘记淘汰了// System.out.println(cf.size()); if(tmp%k==0||tmp%10==k)&#123;//可以被淘汰 cf.poll(); tmp++;&#125; else&#123; result=cf.poll(); cf.offer(result);//不淘汰 tmp++; &#125; &#125; System.out.println(cf.peek());//最后这里开始输的是result TAT,所以细心很，很，很重要 &#125; &#125;&#125;","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"nachos实验1-3","slug":"nachos实验1-3","date":"2018-02-03T16:00:00.000Z","updated":"2018-05-05T08:31:21.042Z","comments":true,"path":"2018/02/04/nachos实验1-3/","link":"","permalink":"https://yongbosmart.github.io/2018/02/04/nachos实验1-3/","excerpt":"","text":"ProJ1: Build athread system for kernel processes实验要求In this project， The only packageyou will submit is nachos.threads, so don’t add any source files to any otherpackage. The autograderwill not call ThreadedKernel.selfTest() or ThreadedKernel.run(). If there isany kernel initialization you need to do, you should finish it beforeThreadedKernel.initialize() returns. There are somemandatory autograder calls in the KThread code. Leave them as they are. 实验分析Phase1分析：在这一阶段，我们主要实现nachos的代码部分。 1)阅读并理解nachos系统的线程部分。nachos系统实现了线程fork，为同步实现了信号量。同时提供了锁和利用信号量实现的条件变量。 2)可添加适当的类或代码，补充并完善Thread，实现合理正确的同步代码。 Task1.1 KThread.join()实验要求：实现KThread的join方法，注意其它的线程不必调用join()，但是如果 join()被调用的话，也只能被调用一次。对 join()第二次调用的执行结果是没有定义的，即使第二次调用者和第一个不同。无论有没有被 join，一个进程都必须正常结束。 实验分析：线程调用了join，即把时间片从当前线程手中抢了过来。主要作用是使当前线程阻塞。因此join方法需要一个等待队列，存放因其调用而存放的前当前线程。同时，在调用者结束时，要释放（唤醒）自己等待队列中的线程。 例如，在a线程中调用b.join不过是让a排在了b的后面。 在实现过程中需要关中断，避免因时钟中断引起的调度的发生。 实验实现：数据结构： 一个Threadqueue，用作等待队列。 1public ThreadQueue JoinQueue=null; 关键代码如下： 12345678910111213141516public void join() &#123; Lib.debug(dbgThread, \"Joining to thread: \" + toString()); Lib.assertTrue(JoinCount==0);//join只可调用一次 Lib.assertTrue(this != currentThread); JoinCount++; boolean intState = Machine.interrupt().disable();//关中断，notice时钟中断 if(this.JoinQueue==null)&#123; JoinQueue = ThreadedKernel.scheduler.newThreadQueue(true);//若没有新建，则进行新建。 &#125; if (status != statusFinished&amp;status != statusBlocked)&#123; JoinQueue.acquire(this); JoinQueue.waitForAccess(currentThread);//将当前线程加入到等待队列里 KThread.sleep();//当前线程睡眠 &#125; Machine.interrupt().restore(intState);//恢复中断 &#125; finish方法（把等待队列中的线程唤醒） 在finish中添加以下代码 123456789if(currentThread.JoinQueue!=null)&#123; KThread x =currentThread.JoinQueue.nextThread();//唤醒等待队列中的所有线程 while(x!=null) &#123; x.ready(); x=currentThread.JoinQueue.nextThread(); &#125;&#125; 测试代码:123456789101112131415161718192021222324252627282930313233343536373839404142public class join1_1 &#123; public static void JoinTest()&#123; KThread a=new KThread(new Runnable()&#123;//新建线程a @Override public void run() &#123; // TODO 自动生成的方法存根 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(\"a线程执行第\"+i+\"次\"); &#125; &#125; &#125;); KThread b=new KThread(new Runnable()&#123;//新建线程b @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"b0在运行\"); System.out.println(\"b1在运行\"); System.out.println(\"a插队b\"); a.join();//a调用join for (int i = 2; i &lt; 5; i++) &#123; System.out.println(\"b\"+i+\"在运行\"); &#125; &#125; &#125;); b.fork(); a.fork(); &#125;&#125; 测试结果: Task1.2 Condition实验要求：直接实现条件变量，通过中断的开启与关闭提供原子性。我们提供一个用信号量的示例实现。你的工作是提供一个对等的实现，而不直接使用信号量（你也可以使用锁，即使他们间接使用信号量）。 一旦完成，您将有两选择实现相同的功能。 您的第二个条件变量的实现必须在类nachos.threads.Condition2中。 实验分析：由于对条件变量和信号量有些遗忘，在做这个实验时，又读了《操作系统的设计与实现》，以期对这些有更深的理解。 这本书在实现管程的过程中提到了条件变量： 管程提供了一种实现互斥的简便途径，但这还不够。我们还需要一种办法以使得进程在无法继续运行时被阻塞。在生产者－消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放到管程的过程中，但是生产者在发现缓冲区满的时候如何阻塞？ 解决方法在于引入条件变量(condition variables)，及相关的两个操作：WAIT和SIGNAL。当一个管程过程发现它无法继续时（例如，生产者发现缓冲区满），它在某些条件变量上执行WAIT，如full。这个动作引起调用进程阻塞。它也允许另一个先前被挡在管程之外的进程现在进入管程。另一个进程，如消费者，可以通过对其伙伴正在其上等待的一个条件变量执行SIGNAL来唤醒正在睡眠的伙伴进程。为避免管程中同时有两个活跃进程，我们需要一条规则来通知在SIGNAL之后该怎么办。 由此我们知道，条件变量是与对共享资源的原子操作有关。在没有资源时（条件不满足），条件变量使进程沉睡，在有资源时（条件满足），条件变量再唤醒进程。 在我看来，条件变量代表资源有没有，进而使进程沉睡苏醒，而信号量可以表示资源有多少，当信号量值最大为1，信号量只有两个状态，也可以表示资源有没有，这时它和条件变量作用相同。（Condition1即为这般实现）。 实验实现：因为条件变量帮助线程实现沉睡苏醒，因此需要有一个队列，来存储线程。同样需要一个锁，实现原子操作。 主要数据结构： 12private Lock conditionLock;private Queue&lt;KThread&gt; waitQueue; Sleep（）方法，在条件不满足（没有资源）时，帮助线程沉睡。 12345678910 public void sleep() &#123;//资源没有，沉睡Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean preState = Machine.interrupt().disable();//关中断,信号量不需要是因为信号量内有 waitQueue.offer(KThread.currentThread());//将当前线程加入到waitQueue中conditionLock.release();//释放锁，表示不占用资源了, KThread.sleep();//当前进程进入睡眠 conditionLock.acquire();//线程苏醒时再次拿到锁Machine.interrupt().restore(preState);//恢复中断 &#125; Wake（）方法，唤醒wait队列中的一个线程 1234567891011public void wake() &#123;//资源拥有时，统一的唤醒操作Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean status=Machine.interrupt().disable();//关中断KThread thread = waitQueue.poll();if (thread != null) &#123; thread.ready(); &#125;Machine.interrupt().restore(status); &#125; Wakeall（）方法，利用wake方法，唤醒wait队列中所有线程 12345678910 public void wakeAll() &#123;Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean status=Machine.interrupt().disable();//关中断while(waitQueue.peek()!=null)&#123; wake(); //将waitQueue中的所有线程均唤醒&#125; Machine.interrupt().restore(status); &#125; 测试代码：测试代码采用了类似生产者和消费者模型的形式。 主要逻辑： a[资源有无，资源内容]。 线程a1——》有无资源？若无-》沉睡-》若有-》修改资源。 线程a2——》有无资源？若无-》沉睡-》若有-》修改资源。 线程a3——》有无资源？若无-》产生资源-》唤醒a1/a2。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Condition21_2 &#123; Lock lock = new Lock(); Condition2 con = new Condition2(lock); int array[]=&#123;0,0&#125;;//数组，第一个数表示资源有无，第二个数表示资源内容 public Condition21_2()&#123; &#125; public void condition2test()&#123; KThread a1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire(); if(array[0]==0)&#123; System.out.println(\"线程a1进入睡眠\"); con.sleep(); &#125; if(array[0]&gt;0)&#123;//有资源 array[1]-=500;//消费行为 System.out.println(\"线程a1苏醒\"); System.out.println(\"线程a1修改变量值为\" +array[1]); &#125; lock.release(); &#125; &#125;) ; KThread a2=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire(); if(array[0]==0)&#123; System.out.println(\"线程a2进入睡眠\"); con.sleep(); &#125; if(array[0]&gt;0)&#123;//有资源 array[1]-=500;//消费行为 System.out.println(\"线程a2苏醒\"); System.out.println(\"线程a2修改变量值为\" +array[1]); &#125; lock.release(); &#125; &#125;) ; KThread a3=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire();//共享变量，应当加上互斥锁 if(array[0]==0)&#123; array[1]=1000;//消费行为 System.out.println(\"线程a3修改变量值为\" +array[1]); array[0]++; System.out.println(\"唤醒所有线程\"); con.wakeAll(); &#125; lock.release(); &#125; &#125;); a1.fork(); a2.fork(); a3.fork(); &#125;&#125; 运行结果: Task1.3 Alarm实验要求：完成Alarm类，通过实现waitUntil方法。一个线程调用waitUntil来挂起直到时间到达now+x,在实际中可用于光标闪烁等。这里并不需要到时间后线程被立刻唤醒，只需它们等待过最少的那个时间即可。不需要新建额外的线程，只需要修改waitUntil方法和计时器的中断处理器。WaitUntil方法不局限于一个线程，任意数量的线程可调用并被挂起。 实验分析：这里让我们实现一个让线程睡眠一段时间后再苏醒的机制。因此会需要一个等待队列，存放睡眠的线程，同时也需要存放它们对应的苏醒时间，以在必要时进行唤醒。 与 Alarm 类有关的是 machine.Timer 类，它在大约每 500 个时钟，滴答使调用回调函数(由 Timer.setInterruptHandler 函数设置)。因此, Alarm类的构造函数中首先要设置该回调函数 Alarm.timerInterrupt()。方法在每一次 timer 产生时间中断时遍历队列，检查队列中的时间状态，当线程到了等待的时间就把线程从队列中取出放入就绪队列。 waitUntil（）方法主要让线程睡眠并存储线程和其睡眠时间。它使用了一个队列可以存放线程以及唤醒时间。每次调用时，把当前线程和唤醒时间加入队列，等待唤醒。这里使用LinkedList，方便遍历，移出。 系统响应中断的时机： (1) 中断由中断关闭到中断开启时（即原来是disabled，当执行Interrupt.enable()时，或Interrupt. setStatus(true)时。 (2) Nachos的CPU执行完一条Nachos应用程序指令 上述两种情况下，触发Interrupt.tick()方法对Nachos的时钟进行增量（第一种情况增10，第二种情况增1）。tick()触发checkIfDue()，检查目前有无到期的中断，有则响应所有到期的中断 实验实现:数据结构：一个列表，用于存放线程及其沉睡时间。 1LinkedList&lt;Waiter&gt; Wa; 1234567891011121314151617181920public class Waiter &#123; KThread kt=null; long time=0; public Waiter(KThread kt,long time)&#123; this.kt=kt; this.time=time; &#125; public KThread getKt() &#123; return kt; &#125; public void setKt(KThread kt) &#123; this.kt = kt; &#125; public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125;&#125; WaitUntil方法，让线程沉睡一定时间。 123456789 public void waitUntil(long x) &#123; boolean preStatus = Machine.interrupt().disable(); //系统关中断 long wakeTime = Machine.timer().getTime() + x; //确定唤醒的时间 Waiter x2 = new Waiter(KThread.currentThread(),wakeTime); KThread.currentThread().waketime=wakeTime; Wa.offerLast(x2); //将线程加入到等待队列上 KThread.sleep();//当前线程进入睡眠 Machine.interrupt().restore(preStatus);&#125; TimerInterrupt（）方法，在固定时间将线程唤醒。 在这里，我犯过一个错误，开始的时候，我并不是用linkedlist存，而是用队列queue存，由于放入的顺序并没有按苏醒时间排列，因此不能很好的提出所需线程。后来便换了灵活的linkedlist。这里应该算犯了逻辑错误。 1234567891011public void timerInterrupt() &#123; boolean preState = Machine.interrupt().disable();//关中断 for(int i=0;i&lt;Wa.size();i++ )&#123;//这里很不合适用while的话，因为不是每一次都需要把线程拿出来的！！！ if(Wa.get(i).getTime()&lt;= Machine.timer().getTime())//当苏醒时间&lt;当前时间 &#123; Wa.get(i).getKt().ready();//线程进入就绪状态 Wa.remove(i); &#125; &#125; Machine.interrupt().restore(preState);//恢复中断&#125; 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Alarm1_3 &#123; public static void alarmTest()&#123; Alarm x=new Alarm(); KThread a1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"a1线程开始运行……\"); System.out.println(\"a1线程运行第1次\"); System.out.println(\"a1线程进入休眠||时间为：\"+Machine.timer().getTime()+\"||应在\"+(Machine.timer().getTime() + 800)+\"醒来.\"); x.waitUntil(800); //让a1睡眠； System.out.println(\"唤醒线程：a1\"+\"||时间为：\"+Machine.timer().getTime()); for(int i=2;i&lt;=4;i++)&#123; System.out.println(\"a1线程运行第\"+i+\"次\"); &#125; &#125; &#125;); a1.setName(\"a1\"); KThread b1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"b1线程开始运行……\"); System.out.println(\"b1线程运行第1次\"); System.out.println(\"b1线程运行第2次\"); System.out.println(\"b1线程休眠||时间为：\"+Machine.timer().getTime()+\"||应在\"+(Machine.timer().getTime() + 340)+\"醒来.\"); x.waitUntil(340); //让b1睡眠； System.out.println(\"唤醒线程：b1\"+\"||时间为：\"+Machine.timer().getTime()); for(int i=3;i&lt;=4;i++)&#123; System.out.println(\"线程b1正在运行第\"+i+\"次循环\"); &#125; &#125; &#125;); a1.setName(\"a1\"); b1.setName(\"b1\"); a1.fork(); b1.fork(); &#125;&#125; 实验结果:","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/tags/操作系统/"},{"name":"nachos","slug":"nachos","permalink":"https://yongbosmart.github.io/tags/nachos/"}]},{"title":"nachos介绍","slug":"nachos介绍","date":"2018-01-31T16:00:00.000Z","updated":"2018-05-05T08:24:28.444Z","comments":true,"path":"2018/02/01/nachos介绍/","link":"","permalink":"https://yongbosmart.github.io/2018/02/01/nachos介绍/","excerpt":"","text":"实验目的深入理解计算机操作系统，对上学期操作系统知识进行复习回顾，同时理解操作系统在实际中的应用。对线程（包括同步、信号量、调度）、文件系统（包括分页、文件创建等操作）有进一步的理解和认识。 nachos介绍Nachos的全称是“Not Another Completely Heuristic Operating System”，它是一个可修改和跟踪的操作系统教学软件。它给出了一个支持多线程和虚拟存储的操作系统骨架，可让学生在较短的时间内对操作系统中的基本原理和核心算法有一个全面和完整的了解。 nachos系统及部分源码分析 Nachoes 包整体分析： nachos.ag 包提供了能够自动分层 nachoes 项目的类；nachoes.machine 包提供了实现 nachoes 虚拟机的类；nachoes.security 包主要是用来保护 nachoes 的内核不受到破坏；nachoes.thread 包主要提供了用来实现 nachoes 多线程内核的类；nachoes.userprog 包主要是提供了允许 nachoes 在单独的地址空间中加载和执行单线程用户程序的一些类；nachoes.vm 主要是用来让 nachoes 运行的进程按需求分页，利用一些硬件 TLB 来地址上的一些转换。 nachos线程： 一个KThread对象代表一个Nachos线程，线程级的概念与操作，是在KThread类中体现的，如：线程的创建 (KThread.fork())线程的就绪(KThread.ready())线程的睡眠(KThread.sleep())线程的状态与转换线程的上下文切换（sleep和yield可引起）一个Nachos线程由三部分组成，一个KThread对象，与Kthread对象对应的TCB对象，与TCB对象绑定的Java 线程。java thread、TCB对象、KThread对象之间是一一映射关系。关于Nachos线程的创建KThread NachosThread=new KThread(new KThreadTarget)；NachosThread.fork();KThreadTarget是一个Runnable对象，其run()中代码是子线程的执行体。 KThread主要方法及功能解析： currentThread（）：静态方法，实现返回当前KThread类型线程的操作。KThread（）：构造方法。实现判断当前线程是否为空。如果currentThread不为空，则分配一个新的TCB空间；否则，该方法会创建一个新的线程等待队列，将新线程加入等待队列中，将新线程设为当前线程，将tcb指向当前TCB空间，并修改新线程的状态（会由等待改变为运行状态），检查toBeDestory值等一系列线程运行前的准备工作。KThread(Runnabletarget)：构造方法，创建一个新的KThread，并传递给它一个对应的java线程。setTarget(Runnabletarget)：为KThread设置要运行它的对应的java线程。fork（）：创建线程的方法。先运行关中断操作，然后对应的tcb启动一个java线程，调用runThread方法，然后将其加入等待队列中。runThread（）：线程运行。先调用begin（）方法，然后让KThread对应的java线程run（）方法，最后调用finish（）方法，结束线程。begin（）：调用了restoreState（）方法，该方法实现了KTread运行前的一系列准备工作。finish（）：该方法实现了当当前线程运行完成后，将等待队列中下一个线程拿出。yield（）：静态方法，将当前线程加入等待队列，引起调度。sleep（）：静态方法，拿出等待队列中的下一个进程即将运行，将当前线程进入等待队列中，引起调度。ready（）：设置当前线程状态为等待，加入就绪队列。creatIdleThread（）方法：创建一个闲逛线程，永远不会被阻塞，只有当其他所有线阻塞时才运行，永远不会被加入到等待队列。runNextThread（）方法：取出等待队列中的下一个线程并使其运行。run（）方法：先将当前线程加入就绪队列，调用savaState方法，准备放弃CPU。调用run方法的线程设为当前线程，tcb进行上下文切换，调用resoreState方法，使当前线程做运行前的准备工作。 nachos中锁的使用： nachos中提供锁，以实现同步等。 Lock类主要方法如下：acquire（）：若当前线程没有持有锁，可原子地得到锁。关中断。如果锁持有者不为空，则将当前线程加入waitQueue，否则取出当前线程让他得到锁。开中断。release（）:释放锁，即让waitQueue里的下一个线程得到锁，并将其加入等待队列。isHeldByCurrentThread()：判断当前线程是否持有锁。 nachos中的中断系统： nachos在初始化时会创建interrupt controller（中断控制器），对外部提供开关中断的接口,供其它程序调用，保证程序原子性。外部程序可以调用中断控制器提供的接口开关中断（disable()与enable()）当为一个设备设置中断时，可在该设备的类中调用Interrupt.schedule()，该方法需要三个参数 (when:该中断何时到期可以响应；type: 中断类型；handler: 响应该中断时执行的中断处理程序)。nachos的中断不是实时响应，而是在设置中断时提供一个时间参数time，从设置中断开始的time时刻后，该中断到期，可以响应该中断。开关中断操作：开中断： public boolean enable() { setStatus(true); }关中断： public boolean disable() {setStatus(false); }Nachos中断控制器模拟了一个时钟，该时钟从nachos启动时开始计数(ticks)，作为nachos的系统时间。当nachos模拟的CPU执行完一条指令，ticks=ticks+1，当中断状态从disabled转到enabled，ticks+10 。系统调用 checkIfDue 来执行中断查询，在hander中安排调度。涉及类：Machine.Interrupt模仿底层的中断硬件，提供了方法setStatus，来设置能够或不能够中断。记录所有硬件设备可能引起的行为将发生的中断和什么时间他们可能出现。这个模块也记录模拟的节拍，下面情况发生时节拍增长:之前是关中断，开了中断后+10；每秒百万条指令已经执行后+1。中断（包括时间片上下文切换）不可以出现在开中断时的任何代码处。但只在模拟节拍前进时可以，以便它可以成为模拟硬件的节拍来调用中断控制。这意味着错误的同步代码可以在这个模拟硬件上运行（甚至在随意的时间片），但是却不能在真正的硬件上运行。即使nachos不能一直察觉到你的程序在现实中是错的，你也应该写正确的同步代码。Machine.Timer该类是计时器类，控制着系统时间和计时器中断。其核心是Timer.scheduleInterrupt()，与 Timer.timerInterrupt()相互作用维持计时器中断。Timer.scheduleInterrupt()中获取Status.TimerTicks 来安排未来的调度时间（也就是调度间隔）并利用随机数制造调度时间的不稳定性（0~25），当 timerInterrput()被执行，会再次执行 Timer.scheduleInterrupt()安排下次的调度，而 timerInterrrput()中会执行 Timer.handler 的 run 方法，这个handler 是由 setHandler 传入的定时器中断。至于 AutoGraderInterrupt，虽然 delay为 1，但是由于其 scheduleInterrupt 安排在 timerIntterupt 中，也是每 Stats.TimerTicks执行一次，该中断处理程序会对权限进行检查，保证调度器有权限来调度。 nachos中的文件系统： Nachos 文件系统都实现了 FileSystem 接口，提供打开文件和删除文件的方法。所有的文件都要实现 OpenFile 类，作为文件系统返回的文件。OpenFile 定义了Nachos的一个文件及对文件的相关操作，类似于Java中的File类。Nachos系统利用java的File实现nachos文件系统的open(), remove(), read(), write(), close()具体实现。 Userprocess类：包括一个用户进程，一个文件表，以及有关正在执行的程序的信息。execute方法方法：根据文件名和参数，用指定的参数来执行可执行文件。readVirtualMemoryString方法：从进程的虚拟内存中读取内容并转化成字符串的格式。intreadVirtualMemor方法：将该进程的虚拟内存中的数据传到指定的数组中。 Userkernel类：继承自ThreadedKernel类，实现一个内核支持多个用户进程，（实现多道程序设计。）Initialize初始化一个内核，创建一个同步控制台；selftest（）进行自检，控制台是否运行正常；UserProcesscurrentProcess（）用来获得当前进程；run（）方法是通过创造一个进程或是在里面运行一个脚本程序来开始运行用户程序，而这个必须通过运行的脚本程序的名字是靠Machine.getShellProgramName()返回的；terminate（）方法就是用来停止内核不返回。 SynchConsole类：为机器的控制台提供一个简单的同步的接口，而这个接口也可以被OpenFile的对象访问。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/tags/操作系统/"},{"name":"nachos","slug":"nachos","permalink":"https://yongbosmart.github.io/tags/nachos/"}]}]}