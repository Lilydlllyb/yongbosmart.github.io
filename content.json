{"meta":{"title":"Yongbosmart","subtitle":" Follow excellence ,and success will chase you","description":"Follow excellence ,and success will chase U","author":"yongbosmart","url":"https://yongbosmart.github.io"},"pages":[{"title":"","date":"2018-05-06T01:42:31.884Z","updated":"2018-05-06T01:42:18.601Z","comments":true,"path":"baidu_verify_GyMbpHRSjz.html","permalink":"https://yongbosmart.github.io/baidu_verify_GyMbpHRSjz.html","excerpt":"","text":"GyMbpHRSjz"},{"title":"算法作业-有向图（2）","date":"2018-03-27T16:00:00.000Z","updated":"2018-05-05T08:22:27.438Z","comments":true,"path":"算法作业-有向图（2）.html","permalink":"https://yongbosmart.github.io/算法作业-有向图（2）.html","excerpt":"","text":"上次回顾：找图中的最短路径求得图中的强连通通路"},{"title":"categories","date":"2018-04-30T12:40:46.000Z","updated":"2018-04-30T13:37:04.076Z","comments":false,"path":"categories/index.html","permalink":"https://yongbosmart.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-04-27T03:23:29.000Z","updated":"2018-05-25T23:22:15.343Z","comments":true,"path":"about/index.html","permalink":"https://yongbosmart.github.io/about/index.html","excerpt":"","text":"关于我教育经历山东大学 2015年9月 - 2019年6月计算机科学与技术专业 本科 相关课程：数据结构，操作系统，算法设计与分析，机器学习，信息检索，计算机图形学，信息安全导论 技能 Java，C++，Bootstrap(熟悉) Java Web，Python, Tensorflow（努力精进中……） 水水的项目 团队项目 阅读理解系统 MyMajor交友App iBook读书交友软件 个人项目 宾馆客房管理系统 Web-个人博客 各种Java小游戏…… 现在的座右铭~Follow excellence, and success will follow you. Contact me邮箱：yongbosmart@gmail.com GitHub：https://github.com/yongbosmart"},{"title":"tags","date":"2018-04-30T12:40:12.000Z","updated":"2018-04-30T13:35:27.751Z","comments":false,"path":"tags/index.html","permalink":"https://yongbosmart.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Diffie-Hellman 密钥交换&ElGamal协议的安全密钥交换","slug":"Diffie-Hellman 密钥交换","date":"2018-05-17T16:00:00.000Z","updated":"2018-05-19T07:42:08.697Z","comments":true,"path":"2018/05/18/Diffie-Hellman 密钥交换/","link":"","permalink":"https://yongbosmart.github.io/2018/05/18/Diffie-Hellman 密钥交换/","excerpt":"","text":"Diffie-Hellman 密钥交换&amp;ElGamal协议的安全密钥交换离散对数问题在整数中，离散对数是一种基于同余运算和原根的一种对数运算。而在实数中对数的定义 $log_b a$ 是指对于给定的 a 和 b，有一个数 x，使得$b^{x}$ = a。相同地在任何群 G中可为所有整数 k定义一个幂数为$b^{k}$，而离散对数是 $log_b a$指使得$b^{x}$ = a的 整数 k。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 Diffie-Hellman 密钥交换Diffie-Hellman是一种建立密钥的方法，而不是加密方法。然而，它所产生的密钥可用于加密、进一步的密钥管理或任何其它的加密方式。Diffie-Hellman密钥交换算法及其优化首次发表的公开密钥算法出现在Diffie和Hellman的论文中，这篇影响深远的论文奠定了公开密钥密码编码学。 这种密钥交换技术的目的在于使得两个用户安全地交换一个秘密密钥以便用于以后的报文加密. Diffie-Hellman密钥交换算法的有效性依赖于计算离散对数的难度 。 主要过程 所有用户都知道的全局参数 大素数q g : 用来模q的原始根 每个用户生成自己的公钥(对于用户A) 选择一个密钥，(私钥)：数字 $x_{A}$&lt;q 计算公钥：$y_{A}=g^{x_{A}}\\mod q$ 每个用户公开公钥 则用户A&amp;B共享的会话密钥是$K_{AB}$ K_{AB}=g^{x_{A}· x_{B}} \\mod q​ =y_{A}^{x_{B}}\\mod q (B可以计算出来) ​ =y_{B}^{x_{A}}\\mod q (A可以计算出来) From WIKI： 最简单，最早提出的这个协议使用一个质数p的整数模n乘法群)以及其原根g。下面展示这个算法，绿色表示非秘密信息, 红色粗体表示秘密信息 爱丽丝和鲍伯写上一个有限循环群 G 和它的一个生成元 g。 （这通常在协议开始很久以前就已经规定好； g是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 a(很大) 并且将 $g^{a}\\mod p$（大素数）发送给鲍伯。 鲍伯选择一个随机自然数 b （很大）并且将 $g^{b}\\mod p$发送给爱丽丝。 爱丽丝 计算 $(g^{b})^{a} \\mod p$ 。 鲍伯 计算 $(g^{a})^{b} \\mod p$ 。 爱丽丝和鲍伯就同时协商出群元素$g^{ab}$，它可以被用作共享秘密。$(g^{b})^{a}$和$(g^{a})^{b}$因为群乘法交换的。 算法解释爱丽丝和鲍伯最终都得到了同样的值，因为在模p下$g^{ab}$和 $g^{ba}$ 相等。 注意a, b 和 $g^{ab}= g^{ba} \\mod p$ 是秘密的。 其他所有的值 – p, g, $g^{a} \\mod p$, 以及 $g^{b}\\mod p $– 都可以在公共信道上传递。 一旦爱丽丝和鲍伯得出了公共秘密，他们就可以把它用作对称密钥，以进行双方的加密通讯，因为这个密钥只有他们才能得到。 Elgamal密码体制1984年，T.Elgamal提出了一种基于离散对数的公开密钥体制，是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。ElGamal密码体系应用于一些技术标准中，如数字签名标准（DSS）和S/MIME电子邮件标准。与Diffie-Hellman一样，ElGamal的系统用户也是共同选择一个素数q，$g$是q的素跟。 算法描述ElGamal加密算法由三部分组成：密钥生成、加密和解密。 密钥生成密钥生成步骤如下： Alice利用生成元 $g$ 产生一个 q,阶循环群 $G$,的有效描述。该循环群需要满足一定的安全性质。 Alice从 $\\{1,\\cdots,q-1\\}$中随机选择一个 $x$。 Alice计算 $h:=g^{x} \\mod q $。 Alice公开$h$,以及 $G,q,g$ 的描述作为其公钥，并保留 $x$ 作为其私钥。私钥必须保密。 加密其他用户可以通过Alice的公钥进行加密。 用Alice的公钥 $(G,q,g,h)$向她加密一条消息 m的加密算法工作方式如下： 将信息表示成一个整数M，其中$1\\leq M \\leq q-1$，以分组密码序列的方式来发送信息，其中每个分块的长度不小于整数q。 Bob从 $\\{1,\\cdots,q-1\\}$ 随机选择一个 $y$。（私钥） 然后计算 密钥$K=h^{y} \\mod q$。（会话密钥） 将M加密成明文对$(C_{1}，C_{2})$，其中 $C_{1}=g^{y} \\mod q ; C_{2}=K\\cdot M \\mod q $（公钥，加密的信息） 解密Alice利用自己的私钥进行解密。 得到密钥：$K=(C_{1})^{x} \\mod q$ 得到消息$M = (C_{2}K^{-1}) \\mod q$ 如果信息必须分组，然后以加密的密钥块序列发送，那么每个分块要有唯一的x（私钥）。如果x用于多个分块，则利用信息的分块$M_{1}$，攻击者会计算出其他块。 ElGamal的安全性是基于计算离散对数的困难性之上。 参考资料[1]维基百科编者. 迪菲-赫尔曼密钥交换[G/OL]. 维基百科, 2018(20180503)[2018-05-03]. https://zh.wikipedia.org/w/index.php?title=%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B&amp;oldid=49408565. [2]《密码编码学与网络安全 原理与实践》（第6版）斯托林斯著 [3]维基百科编者. ElGamal加密算法[G/OL]. 维基百科, 2016(20161214)[2016-12-14]. https://zh.wikipedia.org/w/index.php?title=ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&amp;oldid=42453545.","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://yongbosmart.github.io/categories/信息安全/"}],"tags":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"https://yongbosmart.github.io/tags/课堂笔记/"}]},{"title":"半边数据结构&网格细分与简化","slug":"计算机图形学-半边数据结构","date":"2018-05-05T16:00:00.000Z","updated":"2018-05-09T13:40:51.653Z","comments":true,"path":"2018/05/06/计算机图形学-半边数据结构/","link":"","permalink":"https://yongbosmart.github.io/2018/05/06/计算机图形学-半边数据结构/","excerpt":"","text":"半边数据结构&amp;网格细分参考博客： https://blog.csdn.net/lafengxiaoyu/article/details/51524361 https://blog.csdn.net/outtt/article/details/78544053 http://www.cnblogs.com/shushen/p/5251070.html 对于表面网络来说，其重要的特点在于拓扑，也就是曲面是如何表达的，而不是其顶点的位置。拓扑的不同造就了不同的数据结构和标准，不同的拓扑，其进行网格查询和编辑的性能也不同。计算机图形学上，通常说的流形是一种几何模型表面（但不是所有的），即二维流形，对应拓扑流形。如果网格的每个边最多被两个面片共用，那么这个网格就是流形网络，否则称为非流形网络。 半边数据结构：最大特点是半边，每个边分为两个半边，每个半边都是一个有向边，方向相反。如果一个边被两个面片公用，则每个面片都能各自拥有一个半边。如果一个边仅被一个面片占用（边界边），则这个面片仅拥有该边的其中一个半边，另一个半边为闲置状态。每一条半边仅存储它的起点指针 半边数据结构仅支持流形网络。 半边数据结构的三个重要的数据结构——顶点、半边、面片 顶点(Vertex)：包含出半边（OutgoingHalfedge）的指针或索引 在半边数据结构中的点储存着x，y，z的位置和以其为起始点的半边的指针。在任意给定的点上存在超过一条我们可以选择的半边，但是我们只需要选择其中一条并且是哪一条没关系，在下面的查询方法中我们会看到解释。 12345678910struct HE_vert &#123; float x; float y; float z; HE_edge* edge; // one of the half-edges emantating from the vertex &#125;; 半边(HalfEdge)：包含终点（StartVertex）、邻接面(AdjacentFace)、下一条半边(NextHalfedge)、相反边（opposite）的指针或索引 12345678struct HE_edge &#123; HE_vert* vert; // vertex at the end of the half-edge HE_edge* pair; // oppositely oriented adjacent half-edge HE_face* face; // face the half-edge borders HE_edge* next; // next half-edge around the face &#125;; 面片(Face)：包含一条起始边（FirstHalfedge）的指针或索引对于一个半边数据结构的简单形式，一个面仅仅需要储存一个围绕它的边的指针，在一些特定场合可能要求我们储存比如材质和法向一类的信息。和上面一样，虽然有很多边围绕着面，我们只需要储存其中一条，而无所谓是哪一条 123456struct HE_face &#123; HE_edge* edge; // one of the half-edges bordering the face &#125;; 现在问题来了。顶点可能有两条或以上的出半边，而顶点的数据表达只有一条出半边，那这条出半边是哪一条？半边的下一条半边又是哪一条？面片的起始半边又是哪一条？通过某个网格的数据结构图（如图1）能看得出这些信息吗？ 答：事实上，半边数据结构的网格的构建通常是通过面列表来创建的，也就是说，正常的构建半边数据结构网格是通过一个一个面片的添加来构建的。 所以面的添加顺序就决定了点边面结构的信息，添加面的方法通常是addFace(a,b,c,…)，a,b,c…参数是该面片按其某条环路顺序排列的顶点的指针或索引。注意，环路可以是顺时针或者逆时针，决定了该面片的方向（法向量的方向）。 三维网格细分算法：Catmull-Clark subdivisionCatmull-Clark细分是一种四边形网格的细分法则，每个面计算生成一个新的顶点，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。 1.网格内部F-顶点位置： 设四边形的四个顶点为v0、v1、v2、v3，则新增加的顶点位置为v = $\\frac{1}{4}$ ×(v0 + v1 + v2 + v3)。 2.网格内部V-顶点位置： 设内部顶点v0的相邻点为v1、v2，…，v2n，则该顶点更新后位置为，其中α、β、γ分别为α = 1 - β - γ。 3.网格边界V-顶点位置： 设边界顶点v0的两个相邻点为v1、v2，则该顶点更新后位置为v = $\\frac{3}{4}×v0 +\\frac{1}{8}$×(v1 + v2)。 4.网格内部E-顶点位置： 设内部边的两个端点为v0、v1，与该边相邻的两个四边形顶点分别为v0、v1、v2、v3和v0、v1、v4、v5，则新增加的顶点位置为v = $\\frac{1}{4}$ (v0 + v1 + vf1 + vf2) = $\\frac{3}{8}$ (v0 + v1) + $\\frac{1}{16}$ (v2 + v3 + v4 + v5)。 5.网格边界E-顶点位置： 设边界边的两个端点为v0、v1，则新增加的顶点位置为v = $\\frac{1}{2}​$ (v0 + v1)。 Loop subdivisionLoop细分是一种三角形网格的细分法则，它按照1-4三角形分裂，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。下图为Loop细分格式的细分掩膜，对于新增加的顶点位置以及原始顶点位置更新规则如下： 1.网格内部V-顶点位置： 设内部顶点v0的相邻点为v1、v2，…，vn，则该顶点更新后位置为，其中。 2.网格边界V-顶点位置： 设边界顶点v0的两个相邻点为v1、v2，则该顶点更新后位置为 v = $\\frac{3}{4}$ ×v0 + $\\frac{1}{8}$ ×(v1 + v2)。。 3.网格内部E-顶点位置（新增点）： 设内部边的两个端点为v0、v1，相对的两个顶点为v2、v3，则新增加的顶点位置为v = $\\frac{3}{8}$ (v0 + v1) + $\\frac{1}{8}$(v2 + v3)。 网格内部某条边的两个端点为v0、v1，共享这条边的两个三角形的面是（v0，v1，v2）和（v0，v1，v3） 4.网格边界E-顶点位置（新增点）： 设边界边的两个端点为v0、v1，则新增加的顶点位置为v = $\\frac{1}{2}$×(v0 + v1)。","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://yongbosmart.github.io/categories/计算机图形学/"}],"tags":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://yongbosmart.github.io/tags/计算机图形学/"}]},{"title":"算法作业-有向图","slug":"算法作业-有向图","date":"2018-03-25T16:00:00.000Z","updated":"2018-05-05T07:27:23.971Z","comments":true,"path":"2018/03/26/算法作业-有向图/","link":"","permalink":"https://yongbosmart.github.io/2018/03/26/算法作业-有向图/","excerpt":"","text":"算法作业​ 近期算法布置了一篇课设，在这里描述一下，并晒一下代码。整体来说算法实验很简单，实现方法也很简单粗暴，不过练习一下图的写法吧。 (PS.博主使用的是eclipse for C++，可以利用debug纠错) 问题描述 生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 将上述有向图变成dag图，从中去掉一些边，不允许使用递归 计算上述dag图中最长路径，并记录下路径 问题一生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 问题分析因为需要用邻接链表存储，因此需要用一个链表结构，基本结构如下： 123456789101112131415161718192021222324252627282930313233struct node&#123;public: node* next=NULL;//下一个 int weight=-1; int ini=0;//入度 int id=-1;//本node的编号public: void init(node* next,int length,int id)&#123;//初始化方法 this-&gt;next=next; this-&gt;weight=length; &#125; void init(int length,int id)&#123;//初始化方法 weight=length; this-&gt;id=id; &#125; void init(int id)&#123;//初始化方法 this-&gt;id=id; &#125; bool existedge(int i)&#123;//查看是否此边已存在。 node* current=this; if(i==id)&#123; return true; &#125;//自环 while(current-&gt;next!=NULL)&#123; if(current-&gt;next-&gt;id==i)&#123; return true; &#125; current=current-&gt;next; &#125; return false; &#125;&#125;; 这里，我写的node的性质比较多，但是事实上是完全没有必要的，如我的小伙伴就只存了一个id，后来证明她这种做法更为合理。 下面需要考虑建一个图需要什么样的方法，由于博主之前写过后缀树一类的，因此这个还是很easy的， 12345678910111213141516171819202122class Arithmex1 &#123;public: Arithmex1(int , int ); virtual ~Arithmex1(); int n=0;//顶点数 int e=0;//边数 int time=0; bool create() ;//创建图，是否存在边 bool insertEdge(int,int); //插入边 bool eraseEdge(int,int);//删除边 int weight(int,int);//某一边的权重 int distance(int);//任选一点为源点，计算s到其它点的距离 void dfs(int); int maxdis();//计算dag图中最长路径，并记录下路径 void dag();//将图变成dag图// 其他方法 bool directed(); void print();//图的打印&#125;; 下面开始图的主要代码： create方法： 123456789101112131415161718bool Arithmex1::create()&#123; srand(10);//设置随机数种子 graph=new node[n];//是一个装了node（首）的数组 for(int i=0;i&lt;n;i++)&#123; graph[i].init(1,i+1);//于是附上初值，权重为1，编号为i+1; &#125; int j=0; while(j&lt;e)&#123; int tmp1=rand()%n+1;//对应ID int tmp2=rand()%n+1;//dui if(!graph[tmp1-1].existedge(tmp2))&#123; insertEdge(tmp1,tmp2); &#125;else&#123; continue; &#125; j++; &#125;&#125; insertEdge方法(简单的，链表插入的方法)： 123456789101112131415bool Arithmex1::insertEdge(int a,int b)&#123;//插入边 if(!graph[a-1].existedge(b))&#123; node* current=&amp;graph[a-1]; while(current-&gt;next!=NULL)&#123; current=current-&gt;next; &#125; node *newnode=new node(); newnode-&gt;init(1,b); current-&gt;next=newnode; graph[b-1].ini++; return true; &#125; return false;&#125; 博主为了方便，写的方法比较粗暴，因此只是作为参考。值得注意的是，当我们以node来表示节点时，节点在存储空间内不止有一个。如下图：数组中有一个1，链表中2/4后也均有1，因此就像上面说的，在node struct中增加属性没有必要，且可能浪费空间，这时候一个好的做法是维护一个同等规模的数组来保存节点的属性 下面是需要计算源点s到图中各点的距离，显然可以用BFS,主要思路是维持一个数组存储长度，子节点的长度是父节点长度+1； 123456789101112131415161718192021222324252627282930313233343536373839int Arithmex1::distance(int i)&#123; int source=i; node* current=&amp;graph[source-1];//得到源点位置 int tip[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//标记，有没有被找到过 tip[j]=0; &#125; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离，有多远 tis[j]=-1;//开始认为不可达 &#125; tip[source-1]=-1;//设为首节点认为已标记 tis[source-1]=0;//距源点为0 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 if(tip[cnode-&gt;next-&gt;id-1]!=-1)&#123;//如果没有做过标记 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tip[cnode-&gt;next-&gt;id-1]=-1;//同时做上标记，已扫描// cout&lt;&lt;cnode-&gt;next-&gt;id&lt;&lt;\" \"&lt;&lt;tis[cnode-&gt;next-&gt;id-1]&lt;&lt;\" ]]\"; &#125; cnode=cnode-&gt;next;//去下一个 &#125; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;graph[i].id&lt;&lt;\"的距离是==&gt; \"&lt;&lt;tis[i]; cout&lt;&lt;endl; &#125;&#125; 问题二将上述有向图变成dag图，从中去掉一些边，不允许使用递归 问题分析这里的一个简单思路就是删除返回边。根据《算法导论》上的算法描述，即dfs时遇到灰色节点，边可被删除。难点主要在于白色、黑色、灰色（也可以是开始时间、结束时间）的判定。另一个难点在于不允许使用递归。这里面有很多种情况，需要仔细判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void Arithmex1::dfs(int start)&#123; //链表属性 node* current=&amp;graph[start-1];//得到源点位置 stack&lt;int&gt; ppid;//记录压入栈时的先驱点 stack&lt;node*&gt; dfss;//记录压入栈的node，有一个固定的id，只需要用id与遍历 ppid.push(-1);//起始点先驱点为-1 dfss.push(current);//放入当前点 while(!dfss.empty())&#123; node* newnode=dfss.top();//得到node// cout&lt;&lt;\"新一轮循环\"&lt;&lt;newnode-&gt;id&lt;&lt;endl; dfss.pop(); int tpid=ppid.top();//当前点newnode押出栈时的先驱点 ppid.pop();//当前节点先驱点 if(pro[newnode-&gt;id-1].color==0)&#123;//如果其颜色=0 pro[newnode-&gt;id-1].color =1;//pop出，正式找其它点，变灰色 pro[newnode-&gt;id-1].distime=++time;//发现时间 node* current=&amp;graph[newnode-&gt;id-1];//找到图中它的位置就可以遍历链表 int num=0;//是否变黑，只要push进去节点，说明都没有完成，完成的才变黑 while(current!=NULL&amp;&amp;current-&gt;next!=NULL)&#123;//遍历其邻接链表 if(pro[current-&gt;next-&gt;id-1].color ==0)&#123;//如果没有做过标记 pro[current-&gt;next-&gt;id-1].pid=newnode-&gt;id;//随时会变会更新的pid dfss.push(current-&gt;next);//压入栈 ppid.push(newnode-&gt;id);//这个对应的pid// cout&lt;&lt;\"放入\"&lt;&lt;current-&gt;next-&gt;id&lt;&lt;endl; num++;//操作未完成 &#125;else if(pro[current-&gt;next-&gt;id-1].color==1)&#123;//如果找到了灰色的，返回边。// cout&lt;&lt;current-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl;// cout&lt;&lt;current-&gt;next-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl; change=eraseEdge(newnode-&gt;id,current-&gt;next-&gt;id);//删除// print(); &#125; if(!change)&#123; current=current-&gt;next; &#125;else&#123; change=false; &#125; &#125; if(num==0)&#123;//叶子节点或者无用节点，本节点可以为0 pro[newnode-&gt;id-1].color=2;//黑色 pro[newnode-&gt;id-1].fintime=++time; //开始追根溯源 int tmpid=pro[newnode-&gt;id-1].pid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; // tmpid=pro[tmpid-1].pid; &#125; &#125; &#125;else if(pro[newnode-&gt;id-1].color==2)&#123;//早之前已经发现 int tmpid=tpid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123;// cout&lt;&lt;tmpid&lt;&lt;\"pout\"&lt;&lt;endl; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; &#125; &#125; &#125;&#125; 因为有的节点入度=0，即一次dfs会忽视它们，因此可以采用直接遍历的方法 1234567void Arithmex1::dag()&#123; for(int i=0;i&lt;n;i++)&#123; if(pro[i].color==0) dfs(i+1); &#125; print();&#125; 问题三计算上述dag图中最长路径，并记录下路径。 问题分析看到这个题，第一感觉是用拓扑序列，因为拓扑头一定是头结点。 但是博主又想偷懒了，拓扑头怎么求？在上文中，我们已经求出了结束时间最晚的那个节点，无疑一定是拓扑头。但是这里，博主直接采用的入度为0的为拓扑头，（再维持一个数组添加入度属性啦，插入边入度+1，删除边入度-1），这里，只要从拓扑头开始bfs（注意，这里让求的是最长路径，因此无需判断bfs时此点有没有访问过，而且是有向无环图，所以不会死循环） 这是一种比较简单的思路，却需要大量空间时间，另一种比较好的方法是完全用拓扑序列来实现。至于一些细节就不再赘述，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889int Arithmex1::maxdis()&#123; int* maxpid; maxpid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=-1; &#125; int* tmppid; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; int lastid=0; int realastid=-1; int maxdis=0; int cc=0; for(int i=0;i&lt;n;i++)&#123;//遍历顶点// cout&lt;&lt;graph[i].ini&lt;&lt;endl; if((graph[i].ini==0))&#123;//入度==0 cc++; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离长短 tis[j]=-1; &#125; tis[i]=0;//到自己的距离为0 int tmpdis=0;// tis[i]=1; node* current=&amp;graph[i];//得到源点位置 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tmpdis=tis[cnode-&gt;next-&gt;id-1]; lastid=cnode-&gt;next-&gt;id; tmppid[cnode-&gt;next-&gt;id-1]=tt-&gt;id; cnode=cnode-&gt;next;//去下一个 &#125; if(cnode-&gt;next==NULL)&#123; lastid=cnode-&gt;id; &#125; &#125; if(maxdis&lt;tmpdis)&#123; realastid=lastid; maxdis=tmpdis; maxpid=tmppid; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=tmppid[j];// cout&lt;&lt;tmppid[j]&lt;&lt;\"||\"&lt;&lt;maxpid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; &#125; &#125; &#125; tmppid=new int[maxdis+1]; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 tmppid[j]=-1; &#125; if(realastid!=-1)lastid=realastid; int jianyan=lastid; tmppid[maxdis]=lastid; int count=maxdis-1; while(jianyan!=-1)&#123; jianyan=maxpid[jianyan-1]; tmppid[count]=jianyan; count--; &#125; cout&lt;&lt;endl; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 cout&lt;&lt;tmppid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return maxdis;&#125; 更多完整代码参见https://github.com/yongbosmart","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"ccf1202-游戏","slug":"ccf1202-游戏","date":"2018-03-23T16:00:00.000Z","updated":"2018-04-30T13:36:44.665Z","comments":true,"path":"2018/03/24/ccf1202-游戏/","link":"","permalink":"https://yongbosmart.github.io/2018/03/24/ccf1202-游戏/","excerpt":"","text":"问题描述有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 问题分析用队列比较简单 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package oj;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class ccf1 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 int n, k; int tmp=1;//记录下一个要数的数 int result=-1; Scanner sc = new Scanner(System.in); n = sc.nextInt();// k =sc.nextInt(); Queue&lt;Integer&gt; cf=new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; cf.offer(i+1);// tmp++; &#125; if(n==1)&#123; result=cf.peek(); System.out.println(result); &#125;else&#123; while(cf.size()&gt;1)&#123;//循环往复的问题,,这里第一轮忘记淘汰了// System.out.println(cf.size()); if(tmp%k==0||tmp%10==k)&#123;//可以被淘汰 cf.poll(); tmp++;&#125; else&#123; result=cf.poll(); cf.offer(result);//不淘汰 tmp++; &#125; &#125; System.out.println(cf.peek());//最后这里开始输的是result TAT,所以细心很，很，很重要 &#125; &#125;&#125;","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"nachos实验1-3","slug":"nachos实验1-3","date":"2018-02-03T16:00:00.000Z","updated":"2018-05-05T08:31:21.042Z","comments":true,"path":"2018/02/04/nachos实验1-3/","link":"","permalink":"https://yongbosmart.github.io/2018/02/04/nachos实验1-3/","excerpt":"","text":"ProJ1: Build athread system for kernel processes实验要求In this project， The only packageyou will submit is nachos.threads, so don’t add any source files to any otherpackage. The autograderwill not call ThreadedKernel.selfTest() or ThreadedKernel.run(). If there isany kernel initialization you need to do, you should finish it beforeThreadedKernel.initialize() returns. There are somemandatory autograder calls in the KThread code. Leave them as they are. 实验分析Phase1分析：在这一阶段，我们主要实现nachos的代码部分。 1)阅读并理解nachos系统的线程部分。nachos系统实现了线程fork，为同步实现了信号量。同时提供了锁和利用信号量实现的条件变量。 2)可添加适当的类或代码，补充并完善Thread，实现合理正确的同步代码。 Task1.1 KThread.join()实验要求：实现KThread的join方法，注意其它的线程不必调用join()，但是如果 join()被调用的话，也只能被调用一次。对 join()第二次调用的执行结果是没有定义的，即使第二次调用者和第一个不同。无论有没有被 join，一个进程都必须正常结束。 实验分析：线程调用了join，即把时间片从当前线程手中抢了过来。主要作用是使当前线程阻塞。因此join方法需要一个等待队列，存放因其调用而存放的前当前线程。同时，在调用者结束时，要释放（唤醒）自己等待队列中的线程。 例如，在a线程中调用b.join不过是让a排在了b的后面。 在实现过程中需要关中断，避免因时钟中断引起的调度的发生。 实验实现：数据结构： 一个Threadqueue，用作等待队列。 1public ThreadQueue JoinQueue=null; 关键代码如下： 12345678910111213141516public void join() &#123; Lib.debug(dbgThread, \"Joining to thread: \" + toString()); Lib.assertTrue(JoinCount==0);//join只可调用一次 Lib.assertTrue(this != currentThread); JoinCount++; boolean intState = Machine.interrupt().disable();//关中断，notice时钟中断 if(this.JoinQueue==null)&#123; JoinQueue = ThreadedKernel.scheduler.newThreadQueue(true);//若没有新建，则进行新建。 &#125; if (status != statusFinished&amp;status != statusBlocked)&#123; JoinQueue.acquire(this); JoinQueue.waitForAccess(currentThread);//将当前线程加入到等待队列里 KThread.sleep();//当前线程睡眠 &#125; Machine.interrupt().restore(intState);//恢复中断 &#125; finish方法（把等待队列中的线程唤醒） 在finish中添加以下代码 123456789if(currentThread.JoinQueue!=null)&#123; KThread x =currentThread.JoinQueue.nextThread();//唤醒等待队列中的所有线程 while(x!=null) &#123; x.ready(); x=currentThread.JoinQueue.nextThread(); &#125;&#125; 测试代码:123456789101112131415161718192021222324252627282930313233343536373839404142public class join1_1 &#123; public static void JoinTest()&#123; KThread a=new KThread(new Runnable()&#123;//新建线程a @Override public void run() &#123; // TODO 自动生成的方法存根 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(\"a线程执行第\"+i+\"次\"); &#125; &#125; &#125;); KThread b=new KThread(new Runnable()&#123;//新建线程b @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"b0在运行\"); System.out.println(\"b1在运行\"); System.out.println(\"a插队b\"); a.join();//a调用join for (int i = 2; i &lt; 5; i++) &#123; System.out.println(\"b\"+i+\"在运行\"); &#125; &#125; &#125;); b.fork(); a.fork(); &#125;&#125; 测试结果: Task1.2 Condition实验要求：直接实现条件变量，通过中断的开启与关闭提供原子性。我们提供一个用信号量的示例实现。你的工作是提供一个对等的实现，而不直接使用信号量（你也可以使用锁，即使他们间接使用信号量）。 一旦完成，您将有两选择实现相同的功能。 您的第二个条件变量的实现必须在类nachos.threads.Condition2中。 实验分析：由于对条件变量和信号量有些遗忘，在做这个实验时，又读了《操作系统的设计与实现》，以期对这些有更深的理解。 这本书在实现管程的过程中提到了条件变量： 管程提供了一种实现互斥的简便途径，但这还不够。我们还需要一种办法以使得进程在无法继续运行时被阻塞。在生产者－消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放到管程的过程中，但是生产者在发现缓冲区满的时候如何阻塞？ 解决方法在于引入条件变量(condition variables)，及相关的两个操作：WAIT和SIGNAL。当一个管程过程发现它无法继续时（例如，生产者发现缓冲区满），它在某些条件变量上执行WAIT，如full。这个动作引起调用进程阻塞。它也允许另一个先前被挡在管程之外的进程现在进入管程。另一个进程，如消费者，可以通过对其伙伴正在其上等待的一个条件变量执行SIGNAL来唤醒正在睡眠的伙伴进程。为避免管程中同时有两个活跃进程，我们需要一条规则来通知在SIGNAL之后该怎么办。 由此我们知道，条件变量是与对共享资源的原子操作有关。在没有资源时（条件不满足），条件变量使进程沉睡，在有资源时（条件满足），条件变量再唤醒进程。 在我看来，条件变量代表资源有没有，进而使进程沉睡苏醒，而信号量可以表示资源有多少，当信号量值最大为1，信号量只有两个状态，也可以表示资源有没有，这时它和条件变量作用相同。（Condition1即为这般实现）。 实验实现：因为条件变量帮助线程实现沉睡苏醒，因此需要有一个队列，来存储线程。同样需要一个锁，实现原子操作。 主要数据结构： 12private Lock conditionLock;private Queue&lt;KThread&gt; waitQueue; Sleep（）方法，在条件不满足（没有资源）时，帮助线程沉睡。 12345678910 public void sleep() &#123;//资源没有，沉睡Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean preState = Machine.interrupt().disable();//关中断,信号量不需要是因为信号量内有 waitQueue.offer(KThread.currentThread());//将当前线程加入到waitQueue中conditionLock.release();//释放锁，表示不占用资源了, KThread.sleep();//当前进程进入睡眠 conditionLock.acquire();//线程苏醒时再次拿到锁Machine.interrupt().restore(preState);//恢复中断 &#125; Wake（）方法，唤醒wait队列中的一个线程 1234567891011public void wake() &#123;//资源拥有时，统一的唤醒操作Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean status=Machine.interrupt().disable();//关中断KThread thread = waitQueue.poll();if (thread != null) &#123; thread.ready(); &#125;Machine.interrupt().restore(status); &#125; Wakeall（）方法，利用wake方法，唤醒wait队列中所有线程 12345678910 public void wakeAll() &#123;Lib.assertTrue(conditionLock.isHeldByCurrentThread());boolean status=Machine.interrupt().disable();//关中断while(waitQueue.peek()!=null)&#123; wake(); //将waitQueue中的所有线程均唤醒&#125; Machine.interrupt().restore(status); &#125; 测试代码：测试代码采用了类似生产者和消费者模型的形式。 主要逻辑： a[资源有无，资源内容]。 线程a1——》有无资源？若无-》沉睡-》若有-》修改资源。 线程a2——》有无资源？若无-》沉睡-》若有-》修改资源。 线程a3——》有无资源？若无-》产生资源-》唤醒a1/a2。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Condition21_2 &#123; Lock lock = new Lock(); Condition2 con = new Condition2(lock); int array[]=&#123;0,0&#125;;//数组，第一个数表示资源有无，第二个数表示资源内容 public Condition21_2()&#123; &#125; public void condition2test()&#123; KThread a1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire(); if(array[0]==0)&#123; System.out.println(\"线程a1进入睡眠\"); con.sleep(); &#125; if(array[0]&gt;0)&#123;//有资源 array[1]-=500;//消费行为 System.out.println(\"线程a1苏醒\"); System.out.println(\"线程a1修改变量值为\" +array[1]); &#125; lock.release(); &#125; &#125;) ; KThread a2=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire(); if(array[0]==0)&#123; System.out.println(\"线程a2进入睡眠\"); con.sleep(); &#125; if(array[0]&gt;0)&#123;//有资源 array[1]-=500;//消费行为 System.out.println(\"线程a2苏醒\"); System.out.println(\"线程a2修改变量值为\" +array[1]); &#125; lock.release(); &#125; &#125;) ; KThread a3=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 lock.acquire();//共享变量，应当加上互斥锁 if(array[0]==0)&#123; array[1]=1000;//消费行为 System.out.println(\"线程a3修改变量值为\" +array[1]); array[0]++; System.out.println(\"唤醒所有线程\"); con.wakeAll(); &#125; lock.release(); &#125; &#125;); a1.fork(); a2.fork(); a3.fork(); &#125;&#125; 运行结果: Task1.3 Alarm实验要求：完成Alarm类，通过实现waitUntil方法。一个线程调用waitUntil来挂起直到时间到达now+x,在实际中可用于光标闪烁等。这里并不需要到时间后线程被立刻唤醒，只需它们等待过最少的那个时间即可。不需要新建额外的线程，只需要修改waitUntil方法和计时器的中断处理器。WaitUntil方法不局限于一个线程，任意数量的线程可调用并被挂起。 实验分析：这里让我们实现一个让线程睡眠一段时间后再苏醒的机制。因此会需要一个等待队列，存放睡眠的线程，同时也需要存放它们对应的苏醒时间，以在必要时进行唤醒。 与 Alarm 类有关的是 machine.Timer 类，它在大约每 500 个时钟，滴答使调用回调函数(由 Timer.setInterruptHandler 函数设置)。因此, Alarm类的构造函数中首先要设置该回调函数 Alarm.timerInterrupt()。方法在每一次 timer 产生时间中断时遍历队列，检查队列中的时间状态，当线程到了等待的时间就把线程从队列中取出放入就绪队列。 waitUntil（）方法主要让线程睡眠并存储线程和其睡眠时间。它使用了一个队列可以存放线程以及唤醒时间。每次调用时，把当前线程和唤醒时间加入队列，等待唤醒。这里使用LinkedList，方便遍历，移出。 系统响应中断的时机： (1) 中断由中断关闭到中断开启时（即原来是disabled，当执行Interrupt.enable()时，或Interrupt. setStatus(true)时。 (2) Nachos的CPU执行完一条Nachos应用程序指令 上述两种情况下，触发Interrupt.tick()方法对Nachos的时钟进行增量（第一种情况增10，第二种情况增1）。tick()触发checkIfDue()，检查目前有无到期的中断，有则响应所有到期的中断 实验实现:数据结构：一个列表，用于存放线程及其沉睡时间。 1LinkedList&lt;Waiter&gt; Wa; 1234567891011121314151617181920public class Waiter &#123; KThread kt=null; long time=0; public Waiter(KThread kt,long time)&#123; this.kt=kt; this.time=time; &#125; public KThread getKt() &#123; return kt; &#125; public void setKt(KThread kt) &#123; this.kt = kt; &#125; public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125;&#125; WaitUntil方法，让线程沉睡一定时间。 123456789 public void waitUntil(long x) &#123; boolean preStatus = Machine.interrupt().disable(); //系统关中断 long wakeTime = Machine.timer().getTime() + x; //确定唤醒的时间 Waiter x2 = new Waiter(KThread.currentThread(),wakeTime); KThread.currentThread().waketime=wakeTime; Wa.offerLast(x2); //将线程加入到等待队列上 KThread.sleep();//当前线程进入睡眠 Machine.interrupt().restore(preStatus);&#125; TimerInterrupt（）方法，在固定时间将线程唤醒。 在这里，我犯过一个错误，开始的时候，我并不是用linkedlist存，而是用队列queue存，由于放入的顺序并没有按苏醒时间排列，因此不能很好的提出所需线程。后来便换了灵活的linkedlist。这里应该算犯了逻辑错误。 1234567891011public void timerInterrupt() &#123; boolean preState = Machine.interrupt().disable();//关中断 for(int i=0;i&lt;Wa.size();i++ )&#123;//这里很不合适用while的话，因为不是每一次都需要把线程拿出来的！！！ if(Wa.get(i).getTime()&lt;= Machine.timer().getTime())//当苏醒时间&lt;当前时间 &#123; Wa.get(i).getKt().ready();//线程进入就绪状态 Wa.remove(i); &#125; &#125; Machine.interrupt().restore(preState);//恢复中断&#125; 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Alarm1_3 &#123; public static void alarmTest()&#123; Alarm x=new Alarm(); KThread a1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"a1线程开始运行……\"); System.out.println(\"a1线程运行第1次\"); System.out.println(\"a1线程进入休眠||时间为：\"+Machine.timer().getTime()+\"||应在\"+(Machine.timer().getTime() + 800)+\"醒来.\"); x.waitUntil(800); //让a1睡眠； System.out.println(\"唤醒线程：a1\"+\"||时间为：\"+Machine.timer().getTime()); for(int i=2;i&lt;=4;i++)&#123; System.out.println(\"a1线程运行第\"+i+\"次\"); &#125; &#125; &#125;); a1.setName(\"a1\"); KThread b1=new KThread(new Runnable()&#123; @Override public void run() &#123; // TODO 自动生成的方法存根 System.out.println(\"b1线程开始运行……\"); System.out.println(\"b1线程运行第1次\"); System.out.println(\"b1线程运行第2次\"); System.out.println(\"b1线程休眠||时间为：\"+Machine.timer().getTime()+\"||应在\"+(Machine.timer().getTime() + 340)+\"醒来.\"); x.waitUntil(340); //让b1睡眠； System.out.println(\"唤醒线程：b1\"+\"||时间为：\"+Machine.timer().getTime()); for(int i=3;i&lt;=4;i++)&#123; System.out.println(\"线程b1正在运行第\"+i+\"次循环\"); &#125; &#125; &#125;); a1.setName(\"a1\"); b1.setName(\"b1\"); a1.fork(); b1.fork(); &#125;&#125; 实验结果:","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/tags/操作系统/"},{"name":"nachos","slug":"nachos","permalink":"https://yongbosmart.github.io/tags/nachos/"}]},{"title":"nachos介绍","slug":"nachos介绍","date":"2018-01-31T16:00:00.000Z","updated":"2018-05-05T08:24:28.444Z","comments":true,"path":"2018/02/01/nachos介绍/","link":"","permalink":"https://yongbosmart.github.io/2018/02/01/nachos介绍/","excerpt":"","text":"实验目的深入理解计算机操作系统，对上学期操作系统知识进行复习回顾，同时理解操作系统在实际中的应用。对线程（包括同步、信号量、调度）、文件系统（包括分页、文件创建等操作）有进一步的理解和认识。 nachos介绍Nachos的全称是“Not Another Completely Heuristic Operating System”，它是一个可修改和跟踪的操作系统教学软件。它给出了一个支持多线程和虚拟存储的操作系统骨架，可让学生在较短的时间内对操作系统中的基本原理和核心算法有一个全面和完整的了解。 nachos系统及部分源码分析 Nachoes 包整体分析： nachos.ag 包提供了能够自动分层 nachoes 项目的类；nachoes.machine 包提供了实现 nachoes 虚拟机的类；nachoes.security 包主要是用来保护 nachoes 的内核不受到破坏；nachoes.thread 包主要提供了用来实现 nachoes 多线程内核的类；nachoes.userprog 包主要是提供了允许 nachoes 在单独的地址空间中加载和执行单线程用户程序的一些类；nachoes.vm 主要是用来让 nachoes 运行的进程按需求分页，利用一些硬件 TLB 来地址上的一些转换。 nachos线程： 一个KThread对象代表一个Nachos线程，线程级的概念与操作，是在KThread类中体现的，如：线程的创建 (KThread.fork())线程的就绪(KThread.ready())线程的睡眠(KThread.sleep())线程的状态与转换线程的上下文切换（sleep和yield可引起）一个Nachos线程由三部分组成，一个KThread对象，与Kthread对象对应的TCB对象，与TCB对象绑定的Java 线程。java thread、TCB对象、KThread对象之间是一一映射关系。关于Nachos线程的创建KThread NachosThread=new KThread(new KThreadTarget)；NachosThread.fork();KThreadTarget是一个Runnable对象，其run()中代码是子线程的执行体。 KThread主要方法及功能解析： currentThread（）：静态方法，实现返回当前KThread类型线程的操作。KThread（）：构造方法。实现判断当前线程是否为空。如果currentThread不为空，则分配一个新的TCB空间；否则，该方法会创建一个新的线程等待队列，将新线程加入等待队列中，将新线程设为当前线程，将tcb指向当前TCB空间，并修改新线程的状态（会由等待改变为运行状态），检查toBeDestory值等一系列线程运行前的准备工作。KThread(Runnabletarget)：构造方法，创建一个新的KThread，并传递给它一个对应的java线程。setTarget(Runnabletarget)：为KThread设置要运行它的对应的java线程。fork（）：创建线程的方法。先运行关中断操作，然后对应的tcb启动一个java线程，调用runThread方法，然后将其加入等待队列中。runThread（）：线程运行。先调用begin（）方法，然后让KThread对应的java线程run（）方法，最后调用finish（）方法，结束线程。begin（）：调用了restoreState（）方法，该方法实现了KTread运行前的一系列准备工作。finish（）：该方法实现了当当前线程运行完成后，将等待队列中下一个线程拿出。yield（）：静态方法，将当前线程加入等待队列，引起调度。sleep（）：静态方法，拿出等待队列中的下一个进程即将运行，将当前线程进入等待队列中，引起调度。ready（）：设置当前线程状态为等待，加入就绪队列。creatIdleThread（）方法：创建一个闲逛线程，永远不会被阻塞，只有当其他所有线阻塞时才运行，永远不会被加入到等待队列。runNextThread（）方法：取出等待队列中的下一个线程并使其运行。run（）方法：先将当前线程加入就绪队列，调用savaState方法，准备放弃CPU。调用run方法的线程设为当前线程，tcb进行上下文切换，调用resoreState方法，使当前线程做运行前的准备工作。 nachos中锁的使用： nachos中提供锁，以实现同步等。 Lock类主要方法如下：acquire（）：若当前线程没有持有锁，可原子地得到锁。关中断。如果锁持有者不为空，则将当前线程加入waitQueue，否则取出当前线程让他得到锁。开中断。release（）:释放锁，即让waitQueue里的下一个线程得到锁，并将其加入等待队列。isHeldByCurrentThread()：判断当前线程是否持有锁。 nachos中的中断系统： nachos在初始化时会创建interrupt controller（中断控制器），对外部提供开关中断的接口,供其它程序调用，保证程序原子性。外部程序可以调用中断控制器提供的接口开关中断（disable()与enable()）当为一个设备设置中断时，可在该设备的类中调用Interrupt.schedule()，该方法需要三个参数 (when:该中断何时到期可以响应；type: 中断类型；handler: 响应该中断时执行的中断处理程序)。nachos的中断不是实时响应，而是在设置中断时提供一个时间参数time，从设置中断开始的time时刻后，该中断到期，可以响应该中断。开关中断操作：开中断： public boolean enable() { setStatus(true); }关中断： public boolean disable() {setStatus(false); }Nachos中断控制器模拟了一个时钟，该时钟从nachos启动时开始计数(ticks)，作为nachos的系统时间。当nachos模拟的CPU执行完一条指令，ticks=ticks+1，当中断状态从disabled转到enabled，ticks+10 。系统调用 checkIfDue 来执行中断查询，在hander中安排调度。涉及类：Machine.Interrupt模仿底层的中断硬件，提供了方法setStatus，来设置能够或不能够中断。记录所有硬件设备可能引起的行为将发生的中断和什么时间他们可能出现。这个模块也记录模拟的节拍，下面情况发生时节拍增长:之前是关中断，开了中断后+10；每秒百万条指令已经执行后+1。中断（包括时间片上下文切换）不可以出现在开中断时的任何代码处。但只在模拟节拍前进时可以，以便它可以成为模拟硬件的节拍来调用中断控制。这意味着错误的同步代码可以在这个模拟硬件上运行（甚至在随意的时间片），但是却不能在真正的硬件上运行。即使nachos不能一直察觉到你的程序在现实中是错的，你也应该写正确的同步代码。Machine.Timer该类是计时器类，控制着系统时间和计时器中断。其核心是Timer.scheduleInterrupt()，与 Timer.timerInterrupt()相互作用维持计时器中断。Timer.scheduleInterrupt()中获取Status.TimerTicks 来安排未来的调度时间（也就是调度间隔）并利用随机数制造调度时间的不稳定性（0~25），当 timerInterrput()被执行，会再次执行 Timer.scheduleInterrupt()安排下次的调度，而 timerInterrrput()中会执行 Timer.handler 的 run 方法，这个handler 是由 setHandler 传入的定时器中断。至于 AutoGraderInterrupt，虽然 delay为 1，但是由于其 scheduleInterrupt 安排在 timerIntterupt 中，也是每 Stats.TimerTicks执行一次，该中断处理程序会对权限进行检查，保证调度器有权限来调度。 nachos中的文件系统： Nachos 文件系统都实现了 FileSystem 接口，提供打开文件和删除文件的方法。所有的文件都要实现 OpenFile 类，作为文件系统返回的文件。OpenFile 定义了Nachos的一个文件及对文件的相关操作，类似于Java中的File类。Nachos系统利用java的File实现nachos文件系统的open(), remove(), read(), write(), close()具体实现。 Userprocess类：包括一个用户进程，一个文件表，以及有关正在执行的程序的信息。execute方法方法：根据文件名和参数，用指定的参数来执行可执行文件。readVirtualMemoryString方法：从进程的虚拟内存中读取内容并转化成字符串的格式。intreadVirtualMemor方法：将该进程的虚拟内存中的数据传到指定的数组中。 Userkernel类：继承自ThreadedKernel类，实现一个内核支持多个用户进程，（实现多道程序设计。）Initialize初始化一个内核，创建一个同步控制台；selftest（）进行自检，控制台是否运行正常；UserProcesscurrentProcess（）用来获得当前进程；run（）方法是通过创造一个进程或是在里面运行一个脚本程序来开始运行用户程序，而这个必须通过运行的脚本程序的名字是靠Machine.getShellProgramName()返回的；terminate（）方法就是用来停止内核不返回。 SynchConsole类：为机器的控制台提供一个简单的同步的接口，而这个接口也可以被OpenFile的对象访问。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yongbosmart.github.io/tags/操作系统/"},{"name":"nachos","slug":"nachos","permalink":"https://yongbosmart.github.io/tags/nachos/"}]}]}