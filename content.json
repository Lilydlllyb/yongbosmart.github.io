{"meta":{"title":"Yongbosmart","subtitle":" Follow excellence ,and success will chase you","description":"Ŭ�������Լ���С����~","author":"yongbosmart","url":"https://yongbosmart.github.io"},"pages":[{"title":"About","date":"2018-04-27T03:23:29.000Z","updated":"2018-04-27T03:34:51.343Z","comments":true,"path":"about/index.html","permalink":"https://yongbosmart.github.io/about/index.html","excerpt":"","text":"关于我教育经历山东大学 2015年9月 - 2019年6月计算机科学与技术专业 本科 大三 相关课程：数据结构，操作系统，算法设计与分析，机器学习，信息检索，计算机图形学 技能 Java，C++，Bootstrap(熟悉) Java Web，Python（了解，并努力精进） 机器阅读理解（目前研究方向……） 水水的项目 MyMajor交友软件 主要工作：后台及数据库设计 MyMajor: 一款基于手机 APP 的大学生专业交流共享资源平台。本 APP 主要有聊天、发组队信息、发资源、发文章四个部分，以专业为立足点，以社交为目的。专业与大学生的学习生活密切相关，通过这个APP，大学生们可以进行同专业的交流学习，可以不同专业互补，找到跨学科比赛的队友，也可以了解其它专业，扩充视野，或者为未来转专业、跨专业考研搜集资料。 阅读理解系统 主要工作：算法设计 我们训练了一个非常大的中文语料库，同时用SVM进行训练，区分正确和非正确答案，最后可以达到给出一个问题，系统能快速地在文章中定位相关答案的目的。系统主要目标是辅助人们阅读。 Book读书交友软件 主要工作：后台及数据库设计 iBook是一款基于垂直社交网络的交友软件。它的核心在于读书和交友。因此，它包括聊天、群组、论坛等。与此同时，APP中也有完整的图书数据库。用户可以找到他们喜欢的书，APP也可以对用户进行学习，从而进行智能的读书推荐和好友推荐。 现在的座右铭~怕什么真理无穷，进一步有进一步的欢喜。 Contact me邮箱：yongbosmart@gmail.com 知乎：https://www.zhihu.com/people/yongbosmart/activities 友情链接https://wx1900.github.io/"}],"posts":[{"title":"","slug":"Hibernate学习（1)","date":"2018-04-27T15:04:09.718Z","updated":"2018-04-27T16:19:12.650Z","comments":true,"path":"2018/04/27/Hibernate学习（1)/","link":"","permalink":"https://yongbosmart.github.io/2018/04/27/Hibernate学习（1)/","excerpt":"","text":"来源：https://blog.csdn.net/u010588262/article/details/76667283 @JoinColumn注解一对一现假设有Person表和Address表，是一对一的关系，在Person中有一个指向Address表主键的字段addressID（外键），所以主控方一定是Person，所谓主控方就是能改变关联关系的一方，Person只要改变addressID就改变了关联关系，所以Person是主控方，所以@JoinColumn写在Person类中 12345@OneToOne(cascade=CascadeType.ALL,optional=true,(targetEntity = Address.class) @JoinColumn(name=\"addressID\")//注释本表中指向另一个表的外键。 public Address getAddress() &#123; return address; &#125; 如果两张表是以主键关联的，比如Person表主键是id，Address表主键是address_id 12345@OneToOne(cascade=&#123;CascadeType.ALL&#125;) @PrimaryKeyJoinColumn(name = \"id\", referencedColumnName=\"address_id\") public Address getAddress( ) &#123; return homeAddress; &#125;","categories":[],"tags":[]},{"title":"算法作业-有向图","slug":"算法作业-有向图","date":"2018-03-25T16:00:00.000Z","updated":"2018-04-27T07:50:40.817Z","comments":true,"path":"2018/03/26/算法作业-有向图/","link":"","permalink":"https://yongbosmart.github.io/2018/03/26/算法作业-有向图/","excerpt":"","text":"算法作业​ 近期算法布置了一篇课设，在这里描述一下，并晒一下代码。整体来说算法实验很简单，实现方法也很简单粗暴，不过练习一下图的写法吧。 (PS.博主使用的是eclipse for C++，可以利用debug纠错) 问题描述 生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 将上述有向图变成dag图，从中去掉一些边，不允许使用递归 计算上述dag图中最长路径，并记录下路径 问题一生成100个点，500条边的有向图，任选一点为源点，计算s到其它点的距离。（用邻接链表存储） 问题分析因为需要用邻接链表存储，因此需要用一个链表结构，基本结构如下： 123456789101112131415161718192021222324252627282930313233struct node&#123;public: node* next=NULL;//下一个 int weight=-1; int ini=0;//入度 int id=-1;//本node的编号public: void init(node* next,int length,int id)&#123;//初始化方法 this-&gt;next=next; this-&gt;weight=length; &#125; void init(int length,int id)&#123;//初始化方法 weight=length; this-&gt;id=id; &#125; void init(int id)&#123;//初始化方法 this-&gt;id=id; &#125; bool existedge(int i)&#123;//查看是否此边已存在。 node* current=this; if(i==id)&#123; return true; &#125;//自环 while(current-&gt;next!=NULL)&#123; if(current-&gt;next-&gt;id==i)&#123; return true; &#125; current=current-&gt;next; &#125; return false; &#125;&#125;; 这里，我写的node的性质比较多，但是事实上是完全没有必要的，如我的小伙伴就只存了一个id，后来证明她这种做法更为合理。 下面需要考虑建一个图需要什么样的方法，由于博主之前写过后缀树一类的，因此这个还是很easy的， 12345678910111213141516171819202122class Arithmex1 &#123;public: Arithmex1(int , int ); virtual ~Arithmex1(); int n=0;//顶点数 int e=0;//边数 int time=0; bool create() ;//创建图，是否存在边 bool insertEdge(int,int); //插入边 bool eraseEdge(int,int);//删除边 int weight(int,int);//某一边的权重 int distance(int);//任选一点为源点，计算s到其它点的距离 void dfs(int); int maxdis();//计算dag图中最长路径，并记录下路径 void dag();//将图变成dag图// 其他方法 bool directed(); void print();//图的打印&#125;; 下面开始图的主要代码： create方法： 123456789101112131415161718bool Arithmex1::create()&#123; srand(10);//设置随机数种子 graph=new node[n];//是一个装了node（首）的数组 for(int i=0;i&lt;n;i++)&#123; graph[i].init(1,i+1);//于是附上初值，权重为1，编号为i+1; &#125; int j=0; while(j&lt;e)&#123; int tmp1=rand()%n+1;//对应ID int tmp2=rand()%n+1;//dui if(!graph[tmp1-1].existedge(tmp2))&#123; insertEdge(tmp1,tmp2); &#125;else&#123; continue; &#125; j++; &#125;&#125; insertEdge方法(简单的，链表插入的方法)： 123456789101112131415bool Arithmex1::insertEdge(int a,int b)&#123;//插入边 if(!graph[a-1].existedge(b))&#123; node* current=&amp;graph[a-1]; while(current-&gt;next!=NULL)&#123; current=current-&gt;next; &#125; node *newnode=new node(); newnode-&gt;init(1,b); current-&gt;next=newnode; graph[b-1].ini++; return true; &#125; return false;&#125; 博主为了方便，写的方法比较粗暴，因此只是作为参考。值得注意的是，当我们以node来表示节点时，节点在存储空间内不止有一个。如下图：数组中有一个1，链表中2/4后也均有1，因此就像上面说的，在node struct中增加属性没有必要，且可能浪费空间，这时候一个好的做法是维护一个同等规模的数组来保存节点的属性 下面是需要计算源点s到图中各点的距离，显然可以用BFS,主要思路是维持一个数组存储长度，子节点的长度是父节点长度+1； 123456789101112131415161718192021222324252627282930313233343536373839int Arithmex1::distance(int i)&#123; int source=i; node* current=&amp;graph[source-1];//得到源点位置 int tip[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//标记，有没有被找到过 tip[j]=0; &#125; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离，有多远 tis[j]=-1;//开始认为不可达 &#125; tip[source-1]=-1;//设为首节点认为已标记 tis[source-1]=0;//距源点为0 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 if(tip[cnode-&gt;next-&gt;id-1]!=-1)&#123;//如果没有做过标记 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tip[cnode-&gt;next-&gt;id-1]=-1;//同时做上标记，已扫描// cout&lt;&lt;cnode-&gt;next-&gt;id&lt;&lt;\" \"&lt;&lt;tis[cnode-&gt;next-&gt;id-1]&lt;&lt;\" ]]\"; &#125; cnode=cnode-&gt;next;//去下一个 &#125; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;graph[i].id&lt;&lt;\"的距离是==&gt; \"&lt;&lt;tis[i]; cout&lt;&lt;endl; &#125;&#125; 问题二将上述有向图变成dag图，从中去掉一些边，不允许使用递归 问题分析这里的一个简单思路就是删除返回边。根据《算法导论》上的算法描述，即dfs时遇到灰色节点，边可被删除。难点主要在于白色、黑色、灰色（也可以是开始时间、结束时间）的判定。另一个难点在于不允许使用递归。这里面有很多种情况，需要仔细判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void Arithmex1::dfs(int start)&#123; //链表属性 node* current=&amp;graph[start-1];//得到源点位置 stack&lt;int&gt; ppid;//记录压入栈时的先驱点 stack&lt;node*&gt; dfss;//记录压入栈的node，有一个固定的id，只需要用id与遍历 ppid.push(-1);//起始点先驱点为-1 dfss.push(current);//放入当前点 while(!dfss.empty())&#123; node* newnode=dfss.top();//得到node// cout&lt;&lt;\"新一轮循环\"&lt;&lt;newnode-&gt;id&lt;&lt;endl; dfss.pop(); int tpid=ppid.top();//当前点newnode押出栈时的先驱点 ppid.pop();//当前节点先驱点 if(pro[newnode-&gt;id-1].color==0)&#123;//如果其颜色=0 pro[newnode-&gt;id-1].color =1;//pop出，正式找其它点，变灰色 pro[newnode-&gt;id-1].distime=++time;//发现时间 node* current=&amp;graph[newnode-&gt;id-1];//找到图中它的位置就可以遍历链表 int num=0;//是否变黑，只要push进去节点，说明都没有完成，完成的才变黑 while(current!=NULL&amp;&amp;current-&gt;next!=NULL)&#123;//遍历其邻接链表 if(pro[current-&gt;next-&gt;id-1].color ==0)&#123;//如果没有做过标记 pro[current-&gt;next-&gt;id-1].pid=newnode-&gt;id;//随时会变会更新的pid dfss.push(current-&gt;next);//压入栈 ppid.push(newnode-&gt;id);//这个对应的pid// cout&lt;&lt;\"放入\"&lt;&lt;current-&gt;next-&gt;id&lt;&lt;endl; num++;//操作未完成 &#125;else if(pro[current-&gt;next-&gt;id-1].color==1)&#123;//如果找到了灰色的，返回边。// cout&lt;&lt;current-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl;// cout&lt;&lt;current-&gt;next-&gt;id&lt;&lt;\"shiyan\"&lt;&lt;endl; change=eraseEdge(newnode-&gt;id,current-&gt;next-&gt;id);//删除// print(); &#125; if(!change)&#123; current=current-&gt;next; &#125;else&#123; change=false; &#125; &#125; if(num==0)&#123;//叶子节点或者无用节点，本节点可以为0 pro[newnode-&gt;id-1].color=2;//黑色 pro[newnode-&gt;id-1].fintime=++time; //开始追根溯源 int tmpid=pro[newnode-&gt;id-1].pid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; // tmpid=pro[tmpid-1].pid; &#125; &#125; &#125;else if(pro[newnode-&gt;id-1].color==2)&#123;//早之前已经发现 int tmpid=tpid; if(!ppid.empty())&#123; while(tmpid!=ppid.top())&#123;// cout&lt;&lt;tmpid&lt;&lt;\"pout\"&lt;&lt;endl; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; tmpid=pro[tmpid-1].pid; &#125; &#125;else&#123; pro[tmpid-1].color=2; pro[tmpid-1].fintime=++time; &#125; &#125; &#125;&#125; 因为有的节点入度=0，即一次dfs会忽视它们，因此可以采用直接遍历的方法 1234567void Arithmex1::dag()&#123; for(int i=0;i&lt;n;i++)&#123; if(pro[i].color==0) dfs(i+1); &#125; print();&#125; 问题三计算上述dag图中最长路径，并记录下路径。 问题分析看到这个题，第一感觉是用拓扑序列，因为拓扑头一定是头结点。 但是博主又想偷懒了，拓扑头怎么求？在上文中，我们已经求出了结束时间最晚的那个节点，无疑一定是拓扑头。但是这里，博主直接采用的入度为0的为拓扑头，（再维持一个数组添加入度属性啦，插入边入度+1，删除边入度-1），这里，只要从拓扑头开始bfs（注意，这里让求的是最长路径，因此无需判断bfs时此点有没有访问过，而且是有向无环图，所以不会死循环） 这是一种比较简单的思路，却需要大量空间时间，另一种比较好的方法是完全用拓扑序列来实现。至于一些细节就不再赘述，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889int Arithmex1::maxdis()&#123; int* maxpid; maxpid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=-1; &#125; int* tmppid; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; int lastid=0; int realastid=-1; int maxdis=0; int cc=0; for(int i=0;i&lt;n;i++)&#123;//遍历顶点// cout&lt;&lt;graph[i].ini&lt;&lt;endl; if((graph[i].ini==0))&#123;//入度==0 cc++; int tis[n];//tip，标记源点 for(int j=0;j&lt;n;j++)&#123;//距离长短 tis[j]=-1; &#125; tis[i]=0;//到自己的距离为0 int tmpdis=0;// tis[i]=1; node* current=&amp;graph[i];//得到源点位置 queue&lt;node*&gt; tmp; tmp.push(current);//头结点 while(!tmp.empty())&#123; node* tt=tmp.front();//头结点 tt=&amp;graph[tt-&gt;id-1];//找到在链表中的位置 tmp.pop(); node* cnode=tt; while(cnode-&gt;next!=NULL)&#123;//遍历其邻接链表 tmp.push(cnode-&gt;next);//推入队列 tis[cnode-&gt;next-&gt;id-1]=tis[tt-&gt;id-1]+1; tmpdis=tis[cnode-&gt;next-&gt;id-1]; lastid=cnode-&gt;next-&gt;id; tmppid[cnode-&gt;next-&gt;id-1]=tt-&gt;id; cnode=cnode-&gt;next;//去下一个 &#125; if(cnode-&gt;next==NULL)&#123; lastid=cnode-&gt;id; &#125; &#125; if(maxdis&lt;tmpdis)&#123; realastid=lastid; maxdis=tmpdis; maxpid=tmppid; for(int j=0;j&lt;n;j++)&#123;//距离长短 maxpid[j]=tmppid[j];// cout&lt;&lt;tmppid[j]&lt;&lt;\"||\"&lt;&lt;maxpid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; tmppid=new int[n]; for(int j=0;j&lt;n;j++)&#123;//距离长短 tmppid[j]=-1; &#125; &#125; &#125; &#125; tmppid=new int[maxdis+1]; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 tmppid[j]=-1; &#125; if(realastid!=-1)lastid=realastid; int jianyan=lastid; tmppid[maxdis]=lastid; int count=maxdis-1; while(jianyan!=-1)&#123; jianyan=maxpid[jianyan-1]; tmppid[count]=jianyan; count--; &#125; cout&lt;&lt;endl; for(int j=0;j&lt;maxdis+1;j++)&#123;//距离长短 cout&lt;&lt;tmppid[j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return maxdis;&#125; 更多完整代码参见https://github.com/yongbosmart","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]},{"title":"ccf1202-游戏","slug":"ccf1202-游戏","date":"2018-03-23T16:00:00.000Z","updated":"2018-04-27T13:29:09.056Z","comments":true,"path":"2018/03/24/ccf1202-游戏/","link":"","permalink":"https://yongbosmart.github.io/2018/03/24/ccf1202-游戏/","excerpt":"","text":"###问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 问题分析用队列比较简单 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package oj;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class ccf1 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 int n, k; int tmp=1;//记录下一个要数的数 int result=-1; Scanner sc = new Scanner(System.in); n = sc.nextInt();// k =sc.nextInt(); Queue&lt;Integer&gt; cf=new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; cf.offer(i+1);// tmp++; &#125; if(n==1)&#123; result=cf.peek(); System.out.println(result); &#125;else&#123; while(cf.size()&gt;1)&#123;//循环往复的问题,,这里第一轮忘记淘汰了// System.out.println(cf.size()); if(tmp%k==0||tmp%10==k)&#123;//可以被淘汰 cf.poll(); tmp++;&#125; else&#123; result=cf.poll(); cf.offer(result);//不淘汰 tmp++; &#125; &#125; System.out.println(cf.peek());//最后这里开始输的是result TAT,所以细心很，很，很重要 &#125; &#125;&#125;","categories":[{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/categories/日常练习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://yongbosmart.github.io/tags/算法/"},{"name":"日常练习","slug":"日常练习","permalink":"https://yongbosmart.github.io/tags/日常练习/"}]}]}